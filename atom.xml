<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Littlewin&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://littlewin.info/"/>
  <updated>2016-12-09T06:22:20.271Z</updated>
  <id>http://littlewin.info/</id>
  
  <author>
    <name>Littlewin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再谈Littlewin</title>
    <link href="http://littlewin.info/2016/12/09/%E5%86%8D%E8%B0%88Littlewin/"/>
    <id>http://littlewin.info/2016/12/09/再谈Littlewin/</id>
    <published>2016-12-09T03:28:05.000Z</published>
    <updated>2016-12-09T06:22:20.271Z</updated>
    
    <content type="html"><![CDATA[<p>第一次开始用这个名字，已经是大龄青年了。<br>常看的一本杂志有个编辑笔名叫Littlewing，也不知道是不是受此灵感。</p>
<a id="more"></a>
<p>如果有机会再回顾过往，是否要认真看看另一种模态。</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/public/16-12-9/76266723.jpg" width="70%" height="70%"></p>
<p>但是自己毕竟是自己，薛定谔的猫也没有机会做第一人称的观测者。<br>到底是年纪决定性格，还是性格影响年纪。</p>
<p>以上所言只是语气，并没有认真回答的准备。<br>只是以现在这种阅历，<br>故作高冷，颜值不够。<br>强行中二，会被打的吧。</p>
<blockquote>
<p>没有人喜欢孤独，只是不喜欢失望<br>使你不再孤独的，永远是身边的人</p>
</blockquote>
<p>那么，妥协与追求会平衡在一种简单的气氛里。<br>Littlewin，不失积极，也不会剑走偏锋。<br>原则是，无论过往，就不再纠结。<br>为可能而追求可能，为不能而独善其身。</p>
<p>也许，人的任性，最终都会不多不少，恰如其分。<br>也许，你的名字，最终就是个简单的因果诉求。<br>也许，阴天也能放声唱情歌。</p>
<p>深呼吸，然后享受这调皮又可爱的排比语气。</p>
<p><strong>能看到这里的应该是真爱粉，应该不介意我在自己博客里小小的调皮下了（/手动捂脸）</strong></p>
<blockquote>
<p>Oh her eyes’ her eyes<br>Make the stars look like they’re not shining<br>Her hair’ her hair<br>Falls perfectly without her trying<br>She’s so beautiful<br>And I tell her every day</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5093684&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次开始用这个名字，已经是大龄青年了。&lt;br&gt;常看的一本杂志有个编辑笔名叫Littlewing，也不知道是不是受此灵感。&lt;/p&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="生活" scheme="http://littlewin.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>11月的Littlewin</title>
    <link href="http://littlewin.info/2016/11/20/11%E6%9C%88%E7%9A%84Littlewin/"/>
    <id>http://littlewin.info/2016/11/20/11月的Littlewin/</id>
    <published>2016-11-20T08:01:50.000Z</published>
    <updated>2016-11-21T04:06:16.384Z</updated>
    
    <content type="html"><![CDATA[<p>以前的想法是拿博客来当笔记本用了，专注于技术分享，但实际想想便觉得除了公司的内部技术之外，自己可拿出手的干货实在不多，技术文章也就是做做笔记，做做翻译。笔过留痕，敲出来的字难以形成记忆。</p>
<p>所以还是专注于深度分享，把不愿意或者不甘心po在朋友圈的内容保留起来吧，至少还能有些care的人看一看。</p>
<a id="more"></a>
<p>面对正反两难的选择，有些人会选择抛硬币，不只是因为硬币总能给出单一的答案，而是当你决定要做一个决定的时候，你的心中已经有了一个答案，硬币只是过渡这一秒的一格动画。</p>
<p>我不喜欢掷硬币，这行为太不自信。我尊重心声，我相信人是需要独立在心里打量很多东西，这个过程丰富了你对人性羁绊的理解和认知，让你站在一个更透彻的角度去看待世界。这些经历是必须的，它敦促你的成长和成熟过程。而你应该信任这种从小至老的历练过程，一个选择也许只是逢二进一，而一段心理过程将会孕育出生活的种种可能。</p>
<p>那么生活究竟是孕育了无数的可能，还是带来无尽的选择烦恼？</p>
<p>选择这件事情，是否可以换个问法，是期待结果还是期待意外。</p>
<p>选择重要到直接影响了自己目前的生活状态，而心理的东西，就算一本正经的跟别人讲，也不一定能恰如其分地降落在别人的心坎上。</p>
<p>成长的日子里，经历过一些自我封闭、自我怀疑甚至很低沉的时期。10年前，我想自己应该是一个安静的、胆小怯生的男生，会反反复复的听歌，会不停在脑海里营造每一处路口转角分支的延伸。</p>
<p>如今，确实外向许多，很多话都可以率真地脱口而出。我还是相信越简单的，就越幸福。我尊重生活经历赋予的一切心路历程，渐渐开始放弃纠结或是追悔。</p>
<p>人性除了法律和道德以及自我追求的约束外，在生命的延展上应该是自由的。每一段relationship，每一种实现的动力，每一份情感体验都会蔓延出种种可能，在人生路上形成各种形状和强度的羁绊。</p>
<p>抱歉我还是不能明确的表达出该怎样，会怎样。</p>
<p>或许这就是一种对自己很虔诚的信仰吧。</p>
<p>毕竟，</p>
<blockquote>
<p>用心经营的，怎么会是绝路。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前的想法是拿博客来当笔记本用了，专注于技术分享，但实际想想便觉得除了公司的内部技术之外，自己可拿出手的干货实在不多，技术文章也就是做做笔记，做做翻译。笔过留痕，敲出来的字难以形成记忆。&lt;/p&gt;
&lt;p&gt;所以还是专注于深度分享，把不愿意或者不甘心po在朋友圈的内容保留起来吧，至少还能有些care的人看一看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="生活" scheme="http://littlewin.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello, 大目标</title>
    <link href="http://littlewin.info/2016/11/07/Hello,%20%E5%A4%A7%E7%9B%AE%E6%A0%87/"/>
    <id>http://littlewin.info/2016/11/07/Hello, 大目标/</id>
    <published>2016-11-07T06:58:52.000Z</published>
    <updated>2016-11-08T08:27:15.209Z</updated>
    
    <content type="html"><![CDATA[<p>小幸运，大目标，此刻晴朗<br>小指勾，咧嘴笑，悠哉悠哉</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-11-7/16133495.jpg" alt=""></p>
<a id="more"></a> 
<p>最初的诗，无尽的冗长，<br>看似轻浮的文字，有满身紫荆和木棉的清香，<br>没调整好的眼神，角度凄美，于他乡。</p>
<p>后青春期的坚守，不肯凋谢，<br>虔诚的想象，执着的泪痕，<br>天空之所以放晴，是有关地球自转的360度。</p>
<p>爱肯付出的汗水，爱小王子的蔷薇，<br>生如夏花，心守吾愿，<br>愿每一首诗的终点，都指向温暖。</p>
<p>高中起，执笔写下很多东西，笔下留痕，心中有意，始终愿意为点滴的温暖和心动而准备着。</p>
<p>11月深圳，阳光明媚，肆无忌惮，夏完夏天再夏了秋天，这种直爽的温暖令人愉悦，喜欢光影铺洒在地上，喜欢与晴朗同行。</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-11-8/7134187.jpg" alt=""></p>
<p>最近结束了一段人畜无害的友情，打开心扉，很直观地吐露出了关于美好的种种念想。一波死皮赖脸之后换来了一个很nice的beginning，一个平时大大咧咧的女孩子突然在你面前开始羞涩，而你知道，从那一刻起，你所做的努力需要double了。</p>
<p>认识大目标是一年多前，始终以互开玩笑接触，深入交往是两月前，开场竟然是一个美丽的错误命题。</p>
<p>生活永远比故事精彩，因为生活滋润了你每一个付出努力和行动的愿望。</p>
<p>我喜欢简单明快的节奏，我喜欢直接阐明每一种感受，我喜欢让在乎的人洋溢在自己尽力构造的喜悦中，我喜欢阳光透过树叶微抚脸颊的角度。</p>
<p>Hello，大目标，虽只是开始，而你却已命中了我那么多的预期。也许我还是要走过一条不短的路，陪你消化过往的遗憾和不愉快，陪你渡过情感变化的种种波折，也是我慢慢敲开你心扉，走近你，和建立起能cover你的生活的能力的过程。而我也知，能用默契和时间建立的信任，不需要过多的承诺。</p>
<p>Hello，大目标，也许不久以后便会告诉你，我还有和你一起的两个大大目标，一定要陪我去威斯特法伦南看台去当两个最疯最闹的大多特死忠</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-11-8/29213923.jpg" alt=""></p>
<p>一定要陪我去甲骨文球馆看咱库在现场投进三分</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-11-8/65019381.jpg" alt=""></p>
<p>And从未像现在这般期待早晨，以上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小幸运，大目标，此刻晴朗&lt;br&gt;小指勾，咧嘴笑，悠哉悠哉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/16-11-7/16133495.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="生活" scheme="http://littlewin.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>何以驴得水</title>
    <link href="http://littlewin.info/2016/10/30/%E4%BD%95%E4%BB%A5%E9%A9%B4%E5%BE%97%E6%B0%B4/"/>
    <id>http://littlewin.info/2016/10/30/何以驴得水/</id>
    <published>2016-10-30T08:04:50.000Z</published>
    <updated>2016-11-04T09:54:25.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>生存压力以外的理想主义到底是不是耍流氓<br>脱离知识分子的气韵来黑知识分子的虚伪外表是不是耍流氓<br>抛弃雅俗共赏的勇气勾勒出一个不完整的人性思考轴是不是耍流氓</p>
</blockquote>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-10-30/20940731.jpg" alt=""></p>
<a id="more"></a> 
<p>很遗憾没有看过话剧版的《驴得水》，本以为这是一部延续《夏洛特烦恼》的哈哈类电影，一起度过一个轻松愉快的100分钟然后就过去了，但结果是取乐精神被“睡醒”了，倒是弄得个哭笑不得的结局。</p>
<p>故事背景设定在1942年的边陲山村里，四位甘心清贫，致力于普及农村教育的一老三少为了争取更好的教育资源凭空骗饷，捏造了一个“驴得水”的虚假老师；又遇洋大款慈善事业对口，教育部围绕其钱包制定计划。两条主线交汇在一个原本就不存在的白板上，于是各色人等，围绕主线的发展，开始有了随人性而拉扯出的选择，“不拘小节”，“睡服”，报复，隐忍，虚荣或是疯狂，从而在这个白板上集尽了在理想主义层面知识分子的种种作态。</p>
<p>故事背景脱离当代选择1942算是比较顺利的通过了审查，也符合剧情对人物细节的刻画，同时增加了影射、联想和双关的空间。在悲剧的深坑被一念带起的妥协和不拘小节越挖越深的时候，知识分子的气节在利益、强权和伪和谐面前瞬间崩塌，这种妥协的速度，竟然比一头标题驴被杀而烹之的速度都快。这就是个彻头彻尾的悲剧，但矛盾之初，每个人却似在做着一些你我都熟悉的选择，就像温水煮青蛙，蛙跳时刻我们才幡然醒悟一个虚拟的封闭空间里都都可以发生我们似曾相识的那么多事情，而外面这个现实的，巨大的，现在看来还很丑陋的世界，我们却更熟悉。</p>
<p>故事画风转进的载体还是交给了单纯着又放荡着的张一曼。来到一个偏远贫困的地方，单纯无私却只是为了好玩没人管。放荡但总是愿意为了利益冲突而付出些什么。这不同于男人们的假仗义和孩子们未经世俗荏苒的幼稚想法，说出来了便就这么做了。所以悲剧的主体还是由她来承载了，她所认同，所在乎的团队最终祭出了她，她所看轻，所不屑一顾的铜匠近乎浇灭了她的洒脱，她的放荡不羁，以一种原始而残忍的方式。这是本片最压抑最窒息最难以释怀的部分了，也是一大波女生看后会难受很久的梗。</p>
<p>知识是这场悲剧的导火索，却被讽刺的最体无完肤。本篇没有为人物塑造具体细微的知识分子形象，只是以一个理想主义愿望切入，四位知识分子给一个似未开窍的土疙瘩贴上知识分子的背景，慢慢的揭开其内心懵盲无知的封条，释放出全片反差第二大的怪物角色。知识分子的催化延伸的恶的边界，放大了仇恨的力量，进而连知识本身都被其快消灭殆尽了。这里剧本似乎反转着给出了一个人性本恶的结论，但其实善恶就是一念之间，一个选择，受环境影响，被灌输的原料本身其实也可能满载生活的恶意。</p>
<p>校长女儿在本剧中承载着唯一的希望一路走向正确的道路（^.^ 我们的事业的正确而伟大的）。一个满怀童真的新青年未经权利和利益的过渡在亲情绑架下也被迫放弃追求真善美的最后转机，幸好矛盾在她的悲剧铸造前爆发，草地上撒下五彩缤纷的弹力球，应该是本片尾声出释放出的一丝亲和观众的美好吧。</p>
<p>学工科的喜欢一切具体化，总结一下，就是知识分子在高压下开始妥协由小骗子晋身为大骗子再亲手塑造出悲剧的载体，进而毁掉了自己为之奋斗的理想主义。</p>
<p>没有答案告诉我们知识分子可不可以轻易的谈起理想。</p>
<p>我讲个笑话，你可别哭啊。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;生存压力以外的理想主义到底是不是耍流氓&lt;br&gt;脱离知识分子的气韵来黑知识分子的虚伪外表是不是耍流氓&lt;br&gt;抛弃雅俗共赏的勇气勾勒出一个不完整的人性思考轴是不是耍流氓&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/16-10-30/20940731.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="生活" scheme="http://littlewin.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>小任性大男孩</title>
    <link href="http://littlewin.info/2016/10/17/%E5%B0%8F%E4%BB%BB%E6%80%A7%E5%A4%A7%E7%94%B7%E5%AD%A9/"/>
    <id>http://littlewin.info/2016/10/17/小任性大男孩/</id>
    <published>2016-10-17T07:47:06.000Z</published>
    <updated>2016-10-17T08:04:21.149Z</updated>
    
    <content type="html"><![CDATA[<p>致一个长得像ALEX SANCHEZ的枪手球迷 &amp; 朋友<br><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-10-17/11886208.jpg" width="40%" height="40%"><br><a id="more"></a> </p>
<p>从儿时希望 有面包跟牛奶当早餐<br>而立前也想 留青春和热血不言弃</p>
<p>小任性 一时之快 姿态甩向世界 以便巩固和强化 仅能扮演的角色<br>大实话 余音绕梁 没有任何形状 终究自由而如愿 恰似山间的清风</p>
<p>雨来之时 发型是伞么<br>浪起之时 礁石是港湾么<br>远足之时 风是帆么<br>但满溢着水的世界里 坚信回头是岸</p>
<p>看似鱼贯的穿越 适度卷曲的悲伤<br>其实不然 或许鸡汤本该有三分咸度<br>余下七分 给自己埋下几处伏笔</p>
<p>经过岁月筛选后 还能完整保留在沙滩上<br>一定是 具备了某种特质的形状<br>譬如 用报纸褶皱后准备 起航<br>孩童时期 那一艘 日益膨胀的想象</p>
<p>原谅我 如此大费周章 写下这些 素颜非韵脚<br>只因 我和你一样 都愿做个 半大不小的孩子</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;致一个长得像ALEX SANCHEZ的枪手球迷 &amp;amp; 朋友&lt;br&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/16-10-17/11886208.jpg&quot; width=&quot;40%&quot; height=&quot;40%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="生活" scheme="http://littlewin.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>我理解的有效沟通</title>
    <link href="http://littlewin.info/2016/09/30/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E6%9C%89%E6%95%88%E6%B2%9F%E9%80%9A/"/>
    <id>http://littlewin.info/2016/09/30/我理解的有效沟通/</id>
    <published>2016-09-30T11:34:18.000Z</published>
    <updated>2016-10-08T02:18:50.735Z</updated>
    
    <content type="html"><![CDATA[<p>沟通的目的是进行信息交互，那么参与者一定是信息get和post的双重收益者，至于信息交互后的化学反应，头脑风暴，那是有效沟通的高阶方式了，小生我在日常中也很难遇到。</p>
<p>总结一句话，我认为有效沟通的基础就是“I have post and I have got”。</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-9-30/85454892.jpg" alt=""></p>
<a id="more"></a> 
<h3 id="What-are-you-talking-about"><a href="#What-are-you-talking-about" class="headerlink" title="What are you talking about"></a>What are you talking about</h3><p>基于我们沟通的第一选择是张嘴，那么讲话也就成为沟通中至关重要的一环。声调，语气和颜值不在本文的讨论范围，暂且假设这几维度我们都达标了。接下来考虑几种情况吧，</p>
<ul>
<li><p>有些人出口成章，洋洋洒洒的大段文字。猛地一听觉得很有气势，但仔细理解之后就会发现其中不乏大片的口水话，空话。“假设”，“可能”，“也许”，这些词汇会大量出现在其中，采用假设论证的方法本身是靠谱的，可一开口就绕去一个概率很小的问题显得底气不足，也没有命中重点。</p>
</li>
<li><p>第二类人是典型的悖论分子，他们的语言大都包含攻击性，对于你的每一条观点都会进行反驳，和他们交流的最后你会发现这次沟通已经严重偏离了重点，最后沟通升级为辩论，辩论升级为“语言斗殴”。</p>
</li>
<li><p>最后一类人将他们归并在一起吧，这类人要不就是没话，要不就是半天吐不出一句话。建议他们先去了解下这次沟通的背景，或者尝试将一些观点总结好写下来，否则真是浪费时间。</p>
</li>
</ul>
<p>在这我简单给出我的观点，在有效的沟通中，前期双方都要针对沟通内容提前做好功课，梳理出其中的条条框框。在沟通中，要做到直接明了，命中“why, what, how”这些关键因素。对于该反驳和讨论的核心问题，直接开始讨论；对于次要问题，可以先忽略。沟通后及时发布总结，输出本次达成共识的议题和后续的action point。</p>
<h3 id="How-to-talk"><a href="#How-to-talk" class="headerlink" title="How to talk"></a>How to talk</h3><p>语言学家或者心理学家会告诉你，在沟通时首先 - </p>
<ul>
<li>建立发言自信</li>
<li>学会提问</li>
<li>学会倾听</li>
<li>学会共享信息</li>
<li>学会创造话题</li>
</ul>
<p>以上内容假设你都会，我们讨论点更进阶的。</p>
<p>有效沟通能否成立关键在于信息的有效性，信息的有效程度决定了沟通的有效程度。信息的有效程度又主要取决于它的透明和反馈，so</p>
<ul>
<li><p>讲大家能听懂的内容，如果以一种模棱两可的、含糊不清的文字语言传递一种不清晰的，难以使人理解的信息，对于听众而言没有任何意义。这是一种双向的浪费时间。</p>
</li>
<li><p>等待反馈，讲你的发言内容分段，在每段中间等待听众的理解或提问，确保大家都能理解。</p>
</li>
<li><p>把内容分配给适合的人，一次沟通，或者会议吧，总会有不同的参与者。要明确沟通的对象，有的放矢。</p>
</li>
</ul>
<h3 id="You-should-not"><a href="#You-should-not" class="headerlink" title="You should not"></a>You should not</h3><ul>
<li><p>以内我为中心<br>沟通本身是一种平等的交流行为。自身的思维是影响有效沟通的重要因素，但过于迷信自身思维方法的人必定主观武断，缺乏客观、公正、公平之心。既不能正视自我也不愿正视他人，更谈不上设身处地站在对方的角度考虑问题。有效沟通是一种动态的双向行为，而双向的沟通应得到充分的反馈，只有沟通的主体、客体双方都充分表达了对某一问题的看法，才具备有效沟通的意义。也只有在增强主客体交流的过程中，才能引导人们从不同的角度看问题，消除一些不必要的误解和偏见。</p>
</li>
<li><p>既不讲也不听<br>的确有这些人，带着这样一种消极的心态来参与沟通。如果是不想参与，就不要浪费时间；如果是不清楚背景，请先做homework，再约时间。</p>
</li>
<li><p>说不清楚，听不明白<br>请投入时间精力去练习<br><del>天喔，我们周围为什么要出现这些人</del></p>
</li>
<li><p>虽不强求，但请真诚<br>真诚是理解他人的感情桥梁，这一条，尽量吧。</p>
</li>
</ul>
<h3 id="You-should"><a href="#You-should" class="headerlink" title="You should"></a>You should</h3><p><del>在下方评论写下你们的观点与我交流，我也需要反馈呀</del></p>
<p>如果有必要进行沟通，请让其升级为有效沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;沟通的目的是进行信息交互，那么参与者一定是信息get和post的双重收益者，至于信息交互后的化学反应，头脑风暴，那是有效沟通的高阶方式了，小生我在日常中也很难遇到。&lt;/p&gt;
&lt;p&gt;总结一句话，我认为有效沟通的基础就是“I have post and I have got”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/16-9-30/85454892.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="工作" scheme="http://littlewin.info/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>乍暖还寒时候，最难将息</title>
    <link href="http://littlewin.info/2016/09/18/%E4%B9%8D%E6%9A%96%E8%BF%98%E5%AF%92%E6%97%B6%E5%80%99%EF%BC%8C%E6%9C%80%E9%9A%BE%E5%B0%86%E6%81%AF/"/>
    <id>http://littlewin.info/2016/09/18/乍暖还寒时候，最难将息/</id>
    <published>2016-09-18T13:01:31.000Z</published>
    <updated>2016-09-27T03:38:06.484Z</updated>
    
    <content type="html"><![CDATA[<p>很久没执笔写下一些有关心情和感悟的文字，总觉得现在没有消化不了的情绪，没有抑制不住的情感。</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-9-27/77701867.jpg" alt=""></p>
<a id="more"></a> 
<p>对于自己的目标也就不紧不慢的追着，过得有些过度平凡。</p>
<p>来深圳之后经历过几个阶段，初来对本地环境的排斥和对一段不深厚的异地恋的紧紧依恋，异地恋崩盘之后的无奈和放纵，和有一个平淡无喜报的跨年。</p>
<p>今年年初找到一些方向，已经坚持了数月，从最初目标来看成果甚至超过预期很多，但是一想到快要奔三的人需要面对的准准，不免心中一直惴惴不安。</p>
<p>其实自己一直都是“背负臭皮囊，梦想有日翻身”的典型屌丝IT男心态，很多时候都会重复着睡前呐喊，醒后茫然的状态，并非自己毫无原则和自律，而是从学校一路走过来，对自己的定位一降再降，说白了就是怂吧。</p>
<p>最近貌似看到一个对20-30岁之间的年轻人的幸福感程度评价，除了无聊的职业收入和职位成就感，占比较重的还有“你最近一次外出旅游”和“你是否在一段恋情中”，面对这类问题的时候，自己还真是觉得很尴尬，想不通是不是自己的问题，却每次经历着一些类似的苦果。</p>
<p>好在节奏虽慢但不断，步伐虽缓但不停，对于工作这块未来的期望是早就定好的，这半年来本职工作还算轻松，有了一些时间积累自己想从事的前端内容，应该在年底之前会做为一版release将自己发布出去吧，希望有好的面试机会。</p>
<p>在每日面向谷歌编程的过程中，也翻阅了一些小牛们的blog，一方面悔悟自己当初不能，二来也重新给自己树立一些方法和习惯，在中国，能进入BAT这个level的公司起码证明一个人在自己的专业领域做到了80分以上，而从他们blog可以清晰的看到自本科起就开始积累的技术路线和项目，不一定所产出的项目一定是耳目一新的idea，但他们会长期维护，利用积累的技能去更新和推进，同样会在git上得到很高的认可。</p>
<p>此时应是故乡乍暖还寒，此时应是故乡近中秋，先定个小目标，约个年轻的小美女一起爬山？本月累积跑掉100公里？快点把自己的hexo主题弄好？快点把今年的BAIDU IFE的最后一道大题刷完？在找工作前完成俩成熟的project？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没执笔写下一些有关心情和感悟的文字，总觉得现在没有消化不了的情绪，没有抑制不住的情感。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/16-9-27/77701867.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="生活" scheme="http://littlewin.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript爬坑笔记（三）</title>
    <link href="http://littlewin.info/2016/03/22/JavaScript%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://littlewin.info/2016/03/22/JavaScript爬坑笔记（三）/</id>
    <published>2016-03-22T08:44:09.000Z</published>
    <updated>2016-12-09T03:01:57.561Z</updated>
    
    <content type="html"><![CDATA[<p>这一节介绍一些<strong>JavaScript</strong>的<strong>setTimeout</strong>和<strong>setInterval</strong>方法，以及事件循环处理中的“坑”。</p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/public/16-12-8/34326467.jpg" alt=""></p>
<a id="more"></a>
<h3 id="1-setTimeout和setInterval"><a href="#1-setTimeout和setInterval" class="headerlink" title="1 setTimeout和setInterval"></a>1 setTimeout和setInterval</h3><p>setTimeout和setInterval方法都是浏览器对象，即BOM提供的方法。这两个方法分别用来进行延时执行，和设置时间间隔执行代码。</p>
<h4 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h4><p>setTimeout用来对代码进行一个延时执行，定义为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.setTimeout(<span class="string">"javascript function"</span>, milliseconds);</div></pre></td></tr></table></figure>
<p>两个参数分别是执行代码和延时时间，可以用<code>clearTimeout</code>来取消定时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> timer=setTimeout(<span class="string">"alert('hello world')"</span>, <span class="number">5000</span>);</div><div class="line">clearTimeout(timer);</div></pre></td></tr></table></figure>
<p>setInterval方法用来设定一个时间间隔来执行代码，其定义方式和setTimeout方法类似:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.setInterval(<span class="string">'javascript function'</span>, milliseconds)</div></pre></td></tr></table></figure>
<p>同样的，可以用clearInterval方法来取消setInterval。</p>
<h4 id="1-2-深入原理"><a href="#1-2-深入原理" class="headerlink" title="1.2 深入原理"></a>1.2 深入原理</h4><p>举个简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  setTimeout(<span class="string">'console.log(1)'</span>,<span class="number">0</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<p>结果是先打印2，再打印1，这不难理解。</p>
<blockquote>
<p>setTimeout中的代码会在单独的线程中执行，不同的线程有优先级的区别。</p>
</blockquote>
<p>再看一个特殊的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125; &#125; , <span class="number">100</span>);</div><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(’你好!’); &#125; , <span class="number">200</span>);</div></pre></td></tr></table></figure>
<p>这段代码不会打印“你好!”了。</p>
<blockquote>
<p>这表明js是单线程的运行在浏览器引擎中，只要上面代码没有执行完，下面代码是永远不会执行的。而实际上浏览器提供的两个计时函数，只是告诉浏览器，我要插入回调函数到待执行队列的时间点，而不是执行的时间点。而什么时候执行，则取决于当前执行队列是否空闲。</p>
</blockquote>
<h4 id="1-3-一些例子"><a href="#1-3-一些例子" class="headerlink" title="1.3 一些例子"></a>1.3 一些例子</h4><p>看下面的例子，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果是：0 1 2 3 3 3</p>
<p>这个例子中体现了“异步、作用域、闭包”等内容，其实上面的代码等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">i++;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">i++;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">i++;</div></pre></td></tr></table></figure>
<p>又因为setTimeout是单独的线程，需要等待前面的代码执行完成后再执行，继续等价：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">i++;</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">i++;</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">i++;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;, <span class="number">0</span>);  </div><div class="line"><span class="comment">//弹出 0 1 2 3 3 3</span></div></pre></td></tr></table></figure>
<p>再举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">msg</span>)</span>&#123;  </div><div class="line">  <span class="keyword">this</span>.msg=msg;  </div><div class="line">  <span class="keyword">this</span>.shout=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">    alert(<span class="keyword">this</span>.msg);  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">this</span>.waitAndShout=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">    setTimeout(<span class="keyword">this</span>.shout, <span class="number">2000</span>);  </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> aa = <span class="keyword">new</span> Obj(<span class="string">"xixi"</span>);  </div><div class="line">aa.waitAndShout();</div></pre></td></tr></table></figure>
<p>结果为undefined，这个例子说明是setTimeout里面函数的内部，也就是第一个参数的内部指向window，所以弹出了undefined。</p>
<p>解决的方式也很简单，利用<code>var that = this</code>做一下this的绑定即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">msg</span>)</span>&#123;  </div><div class="line">  <span class="keyword">this</span>.msg = msg;  </div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;  </div><div class="line">  <span class="keyword">this</span>.shout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">    alert(that.msg);  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">this</span>.waitAndShout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">  setTimeout(<span class="keyword">this</span>.shout,<span class="number">5000</span>);  </div><div class="line">  &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj(<span class="string">'xixi'</span>);  </div><div class="line">obj.waitAndShout();</div></pre></td></tr></table></figure>
<h3 id="2-EVENT-LOOP"><a href="#2-EVENT-LOOP" class="headerlink" title="2 EVENT LOOP"></a>2 EVENT LOOP</h3><p>JavaScript的时间循环机制就是主线程在执行间隙去“任务队列”中读取之前添加好的时间，循环往复。</p>
<p>摘张经典大图<a href="http://vimeo.com/96425312" title="event-loop" target="_blank" rel="external">《Help, I’m stuck in an event-loop》</a> </p>
<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/public/16-12-9/98423029.jpg" alt=""></p>
<p>如上图所示，主线程开启堆和栈区，在栈中执行代码，同时调用外部API在“任务队列”中添加各种事件。栈中的代码执行完毕后，主线程去读取任务队列，依次执行相应的回调函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节介绍一些&lt;strong&gt;JavaScript&lt;/strong&gt;的&lt;strong&gt;setTimeout&lt;/strong&gt;和&lt;strong&gt;setInterval&lt;/strong&gt;方法，以及事件循环处理中的“坑”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/public/16-12-8/34326467.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlewin.info/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript爬坑笔记（二）</title>
    <link href="http://littlewin.info/2016/03/10/JavaScript%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://littlewin.info/2016/03/10/JavaScript爬坑笔记（二）/</id>
    <published>2016-03-10T01:16:16.000Z</published>
    <updated>2016-12-06T03:40:49.984Z</updated>
    
    <content type="html"><![CDATA[<p>接着前面的路继续“爬坑”，希望能将JS中更多典型的问题分享出来。<br><img src="http://7xpot0.com1.z0.glb.clouddn.com/public/16-12-5/39797105.jpg" alt=""><br><a id="more"></a></p>
<h3 id="一、数据类型判断"><a href="#一、数据类型判断" class="headerlink" title="一、数据类型判断"></a>一、数据类型判断</h3><p>JavaScript中有5种基本数据类型和一种复杂数据类型。</p>
<ul>
<li><strong>Null</strong>, <strong>Undefined</strong><br>特殊值</li>
<li><strong>number</strong><br>所有的数值类型，也包括伪数值<strong>NaN</strong>和<strong>Infinity</strong></li>
<li><strong>boolean</strong><br><code>true</code>和<code>false</code></li>
<li><strong>string</strong><br>字符类型</li>
</ul>
<p>其余类型在JavaScript中都为Object类型，比如<strong>function</strong>和<strong>array</strong>。</p>
<h4 id="1-typeof方法"><a href="#1-typeof方法" class="headerlink" title="1. typeof方法"></a>1. <code>typeof</code>方法</h4><p><code>typeof</code>方法是JavaScript中返回类型的原生方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// "undefined" </span></div><div class="line"><span class="keyword">typeof</span> <span class="number">0</span>    <span class="comment">// "number" </span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// "boolean" </span></div><div class="line"><span class="keyword">typeof</span> <span class="string">"foo"</span> <span class="comment">// "string" </span></div><div class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object" </span></div><div class="line"><span class="comment">// 注意下面三行</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span>  <span class="comment">// "object" </span></div><div class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// "function" </span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>  <span class="comment">// "number"</span></div></pre></td></tr></table></figure>
<ul>
<li><code>typeof null == &quot;object&quot;</code>算是JS语言中的一个内置Bug。</li>
<li>按照语言数据类型定义，Functions应该属于Object类型。</li>
<li><code>typeof NaN == &#39;number&#39;</code>略显滑稽，NaN本来是Not A Number的缩写。</li>
</ul>
<p>此外<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> &#123;&#125;  <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">typeof</span> []  <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>  <span class="comment">// 'object'</span></div></pre></td></tr></table></figure></p>
<p><code>typeof</code>无法识别具体的Object类型。</p>
<p>简而言之，<code>typeof</code>函数适用于基本类型的判断。同时，由于<strong>Uncaught ReferenceError</strong>的存在，不要用<code>typeof</code>函数检测变量的存在性。最佳实践是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</div><div class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">'function'</span>) &#123;</div><div class="line">    ... <span class="comment">// in case when x is a function</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    ... <span class="comment">// in other cases</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-toString方法"><a href="#2-toString方法" class="headerlink" title="2. toString方法"></a>2. <code>toString</code>方法</h4><p><code>toString</code>方法是最为可靠的类型检测手段，它会将当前对象转换为字符串并输出。<code>toString</code>属性定义在<code>Object.prototype</code>上，因而所有对象都拥有<code>toString</code>方法。 但<strong>Array</strong>, <strong>Date</strong>等对象会重写从<code>Object.prototype</code>继承来的<code>toString</code>， 所以最好用<code>Object.prototype.toString</code>来检测类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></div><div class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></div><div class="line">toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></div><div class="line">toString.call(<span class="number">3</span>); <span class="comment">// [object Number]</span></div><div class="line">toString.call([]); <span class="comment">// [object Array]</span></div><div class="line">toString.call(&#123;&#125;); <span class="comment">// [object Object]</span></div><div class="line"></div><div class="line"><span class="comment">// Since JavaScript 1.8.5</span></div><div class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></div><div class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></div></pre></td></tr></table></figure>
<p>对于原生对象和内置数据类型，<code>toString</code>方法是非常适用的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Animal(name) &#123; </div><div class="line">  this.name = name</div><div class="line">&#125;</div><div class="line">var animal = new Animal("Goofy")</div><div class="line">var class = &#123;&#125;.toString.apply(animal)</div><div class="line">alert(class) // [object Object]</div></pre></td></tr></table></figure>
<h4 id="3-检测自定义类型"><a href="#3-检测自定义类型" class="headerlink" title="3. 检测自定义类型"></a>3. 检测<strong>自定义类型</strong></h4><p>检测自定义类型通常使用<code>instanceof</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123; </div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Goofy"</span>)</div><div class="line"></div><div class="line">alert( animal <span class="keyword">instanceof</span> Animal ) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h4 id="4-Duck-Typing"><a href="#4-Duck-Typing" class="headerlink" title="4. Duck Typing"></a>4. Duck Typing</h4><p>目前前端惯例是使用Duck Typing的方式，比如jQuery是这样判断一个Window的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isWindow: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123; </div><div class="line">  <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; <span class="string">"setInterval"</span> <span class="keyword">in</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、使用匿名函数"><a href="#二、使用匿名函数" class="headerlink" title="二、使用匿名函数"></a>二、使用匿名函数</h3><p>匿名函数就是指没有分配名称，直接通过函数表达式定义的函数。关于函数表达式和函数声明的区别在<a href="http://littlewin.info/2016/02/28/JavaScript%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="JavaScript爬坑笔记（一）">上节</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// function expression</span></div><div class="line"><span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">"hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// in an object</span></div><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"hi"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// event handler</span></div><div class="line">$(<span class="string">"p"</span>).click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">"hello"</span>);</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="comment">// ajax callback from http://api.jquery.com/jQuery.ajax/</span></div><div class="line">$.ajax(&#123;</div><div class="line">  url: <span class="string">"test.html"</span>,</div><div class="line">  context: <span class="built_in">document</span>.body,</div><div class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">"done"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Self-evoking anonymous functions</span></div><div class="line">((<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">"hi"</span>);</div><div class="line">&#125;)());</div></pre></td></tr></table></figure>
<h4 id="使用匿名函数"><a href="#使用匿名函数" class="headerlink" title="使用匿名函数"></a>使用匿名函数</h4><p>匿名函数有如下好处：</p>
<ul>
<li>代码简洁性，通常匿名函数会在回调函数和事件处理函数中被调用。</li>
<li>控制作用域，匿名函数可以创建私有的作用域，不会干扰其他作用域。</li>
<li>匿名函数可以便于实现闭包和递归函数。</li>
</ul>
<h5 id="以jQuery为例"><a href="#以jQuery为例" class="headerlink" title="以jQuery为例"></a>以jQuery为例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// Expose jQuery to the global object</span></div><div class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line"></div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<p>上面是个立即执行的匿名函数，其中定义的变量作用范围都是匿名函数以内，不会影响全局域。而且在函数执行完后，其作用域链也会及时清理。</p>
<h5 id="在递归函数中也常常使用匿名函数"><a href="#在递归函数中也常常使用匿名函数" class="headerlink" title="在递归函数中也常常使用匿名函数"></a>在递归函数中也常常使用匿名函数</h5><p>通常会配合<code>arguments.callee</code>方法一起使用，避免函数名称变更引起的递归错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (f.answers[n] != <span class="literal">null</span>)</div><div class="line">    <span class="keyword">return</span> f.answers[n];</div><div class="line"></div><div class="line">  f.answers[n] = <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>) + <span class="built_in">arguments</span>.callee(n - <span class="number">2</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> f.answers[n];</div><div class="line">&#125;</div><div class="line"></div><div class="line">f.answers =&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fibo = f;</div><div class="line">alert(fibo(<span class="number">10</span>)); <span class="comment">//55</span></div><div class="line">alert(fibo(<span class="number">11</span>)); <span class="comment">//89</span></div></pre></td></tr></table></figure>
<p>这种机制确保即使将函数赋值给另外的变量，也能正常实现函数递归；同时，将每次递归的计算值保存，避免了多次重复的计算过程。</p>
<h5 id="在闭包中的使用"><a href="#在闭包中的使用" class="headerlink" title="在闭包中的使用"></a>在闭包中的使用</h5><p>各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。而匿名函数和闭包基本上是相辅相成的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#foo'</span>).click( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'User clicked on "foo."'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在闭包中使用循环常常出现错误，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">  $(<span class="string">'#Div'</span> + i).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'#Div'</span> + i + <span class="string">" is kicked"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码会输出10次‘#Div10  is kicked’，而利用匿名函数做下修改，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    $(<span class="string">'#Div'</span> + v).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="string">'Div'</span> + v + <span class="string">" is kicked"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;)</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，代码的输出会如我们预期。</p>
<p>更多闭包的细节将在下一章中展开。</p>
<h5 id="A-quiz"><a href="#A-quiz" class="headerlink" title="A quiz"></a>A quiz</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.baz; &#125;,</div><div class="line">  baz: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>]();</div><div class="line">&#125;)(foo.bar);</div></pre></td></tr></table></figure>
<blockquote>
<p>返回值是“undefined”</p>
</blockquote>
<p>关注<strong>this</strong>的指向是理解这个过程的重点，开始调用<code>foo.bar()</code>时，<strong>this</strong>指向<strong>foo</strong>，而在匿名函数中调用<code>arguments[0]()</code>,<strong>this</strong>指向<strong>arguments</strong>，显然<code>arguments.baz</code>是<strong>undefined</strong>。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<h4 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h4><blockquote>
<p>闭包就是能够读取其他函数内部变量的函数。</p>
</blockquote>
<p>闭包这个概念引入了三个作用域链，访问其自己的作用域，访问外部作用域和访问全局作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span> (<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nameIntro = <span class="string">"Your name is "</span>;</div><div class="line">  ​<span class="function"><span class="keyword">function</span> <span class="title">makeFullName</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> nameIntro + firstName + <span class="string">" "</span> + lastName;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> makeFullName ();</div><div class="line">&#125;</div><div class="line"></div><div class="line">showName(<span class="string">"Michael"</span>, <span class="string">"Jackson"</span>); <span class="comment">// Your name is Michael Jackson</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> selections = []; </div><div class="line">  $(<span class="string">".inners"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// this closure has access to the selections variable​</span></div><div class="line">    selections.push (<span class="keyword">this</span>.prop(<span class="string">"name"</span>)); </div><div class="line">    <span class="comment">// update the selections variable in the outer function's scope​</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="闭包的使用原则和注意事项"><a href="#闭包的使用原则和注意事项" class="headerlink" title="闭包的使用原则和注意事项"></a>闭包的使用原则和注意事项</h4><blockquote>
<p>闭包可以在外部函数返回后访问其变量</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">celebrityName</span> (<span class="params">firstName</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nameIntro = <span class="string">"This celebrity is "</span>;</div><div class="line">  <span class="comment">// this inner function has access to the outer function's variables, including the parameter​</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">lastName</span> (<span class="params">theLastName</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> nameIntro + firstName + <span class="string">" "</span> + theLastName;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> lastName;</div><div class="line">&#125;</div><div class="line">​</div><div class="line">​<span class="keyword">var</span> mjName = celebrityName(<span class="string">"Michael"</span>); <span class="comment">// At this juncture, the celebrityName outer function has returned.​</span></div><div class="line">​</div><div class="line">​<span class="comment">// The closure (lastName) is called here after the outer function has returned above​</span></div><div class="line">​<span class="comment">// Yet, the closure still has access to the outer function's variables and parameter​</span></div><div class="line">mjName (<span class="string">"Jackson"</span>); <span class="comment">// This celebrity is Michael Jackson</span></div></pre></td></tr></table></figure>
<p><strong>celebrityName</strong>返回后，实际上相当于在全局域上创建了一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mjName = <span class="function"><span class="keyword">function</span> <span class="title">lastName</span>(<span class="params">theLastName</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> firstName = <span class="string">"Michael"</span>;</div><div class="line">  <span class="keyword">return</span> nameIntro + firstName + <span class="string">" "</span> + theLastName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>闭包储存了外部函数变量的引用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">celebrityID</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> celebrityID = <span class="number">999</span>;</div><div class="line">  <span class="comment">// We are returning an object with some inner functions​</span></div><div class="line">  <span class="comment">// All the inner functions have access to the outer function's variables​</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    getID: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)  </span>&#123;</div><div class="line">      <span class="comment">// This inner function will return the UPDATED celebrityID variable​</span></div><div class="line">      <span class="comment">// It will return the current value of celebrityID, even after the changeTheID function changes it​</span></div><div class="line">      <span class="keyword">return</span> celebrityID;</div><div class="line">    &#125;,</div><div class="line">    setID: <span class="function"><span class="keyword">function</span> (<span class="params">theNewID</span>)  </span>&#123;</div><div class="line">      <span class="comment">// This inner function will change the outer function's variable anytime​</span></div><div class="line">      celebrityID = theNewID;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> mjID = celebrityID(); <span class="comment">// At this juncture, the celebrityID outer function has returned</span></div><div class="line">mjID.getID(); <span class="comment">// 999</span></div><div class="line">mjID.setID(<span class="number">567</span>); <span class="comment">// Changes the outer function's variable</span></div><div class="line">mjID.getID(); <span class="comment">// 567: It returns the updated celebrityId variable</span></div></pre></td></tr></table></figure>
<blockquote>
<p>闭包失效</p>
</blockquote>
<p>参考<a href="#在闭包中的使用" title="在闭包中的使用">在闭包中的使用</a>，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</p>
<p>本文完，以上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着前面的路继续“爬坑”，希望能将JS中更多典型的问题分享出来。&lt;br&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/public/16-12-5/39797105.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlewin.info/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript爬坑笔记（一）</title>
    <link href="http://littlewin.info/2016/02/28/JavaScript%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://littlewin.info/2016/02/28/JavaScript爬坑笔记（一）/</id>
    <published>2016-02-28T02:26:10.000Z</published>
    <updated>2016-12-09T03:01:53.781Z</updated>
    
    <content type="html"><![CDATA[<p>“坑”也就是“陷阱”。由于JavaScript“弱语言”的性质，使得其在使用过程中异常的宽松灵活，但也极为容易“中招”。这些坑往往隐藏着，只有亲自尝试并爬坑，才能在学习与应用的道路上走的一帆风顺。<br>平时积累一些觉得比较有意思或是比较有难度的JavaScript题目，顺便附上理解和心得。既是为了将来的面试做准备，也增强印象以防自己掉进坑里。<br><a id="more"></a></p>
<h3 id="一、-函数声明的预解析"><a href="#一、-函数声明的预解析" class="headerlink" title="一、 函数声明的预解析"></a>一、 函数声明的预解析</h3><h4 id="1-1-函数的声明方式"><a href="#1-1-函数的声明方式" class="headerlink" title="1.1 函数的声明方式"></a>1.1 函数的声明方式</h4><p>定义一个函数有两种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo() &#123;&#125;;                   <span class="comment">// 函数声明</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;    <span class="comment">// 函数表达式</span></div></pre></td></tr></table></figure>
<p>不同之处 - </p>
<ol>
<li>函数表达式后面加括号可以直接执行</li>
<li>函数声明会提前预解析</li>
</ol>
<h4 id="1-2-预解析"><a href="#1-2-预解析" class="headerlink" title="1.2 预解析"></a>1.2 预解析</h4><p>下面这段代码的输出结果是什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">  <span class="built_in">console</span>.log(foo());</div><div class="line">  <span class="keyword">var</span> a =<span class="number">1</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test();</div></pre></td></tr></table></figure>
<blockquote>
<p>undefined和2</p>
</blockquote>
<p>换种写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">  <span class="built_in">console</span>.log(foo());</div><div class="line">  <span class="keyword">var</span> a =<span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>undefined<br>第二条打印会报错 - TypeError: foo is not a function</p>
</blockquote>
<h4 id="1-3-变量提升"><a href="#1-3-变量提升" class="headerlink" title="1.3 变量提升"></a>1.3 变量提升</h4><blockquote>
<p>JavaScript解析器会在自身作用域内将变量和函数声明提前(hoist)。</p>
</blockquote>
<p>也就是说，上面的例子其实被解析器理解解析成了以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">  <span class="keyword">var</span> foo;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">  <span class="built_in">console</span>.log(foo());</div><div class="line">  a = <span class="number">1</span>;</div><div class="line">  foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    return2;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<p>这样也就可以解释，为什么在函数表达式之前调用函数，会返回错误了，因为它还没有被赋值，只是一个未定义变量，当然无法被执行。</p>
<p>变量声明被提到最前（所以不会报出变量不存在的错误），但赋值没有被提前，所以第一句的输出结果是undefined。</p>
<h4 id="1-4-可能的问题"><a href="#1-4-可能的问题" class="headerlink" title="1.4 可能的问题"></a>1.4 可能的问题</h4><p>由于函数声明会被预解析，所以不要使用此种方法来声明不同函数。尝试猜想下面例子的输出结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'1'</span>);</div><div class="line">  &#125;  </div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'2'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">aaa();</div></pre></td></tr></table></figure>
<p>与我们预想的不同，该段代码弹出的是“2”.这是因为两个函数声明在if语句被执行之前就被预解析了，所以if语句根本没有用，调用aaa()的时候直接执行了下面的函数。</p>
<h4 id="1-5-最佳实践"><a href="#1-5-最佳实践" class="headerlink" title="1.5 最佳实践"></a>1.5 最佳实践</h4><ul>
<li>变量和函数声明一定要放在作用域/函数的开头。</li>
<li>函数表达式在赋值后再去使用。</li>
</ul>
<h3 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h3><p>看一下下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = b = <span class="number">5</span>;</div><div class="line">&#125;)();</div><div class="line"><span class="built_in">console</span>.log(b);</div></pre></td></tr></table></figure>
<blockquote>
<p>5</p>
</blockquote>
<p>这个问题考查的要点是两个不同的作用域，’a’被var声明成了一个局部变量，但是’b’实际上没有被定义，所以它是一个全局变量。<br>如果你选择了strict mode，上面的代码就会报Uncaught ReferenceError，因为b没有被定义，它可以帮你检查出代码的一些问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  <span class="keyword">var</span> a = <span class="built_in">window</span>.b = <span class="number">5</span>;</div><div class="line">&#125;)();</div><div class="line"><span class="built_in">console</span>.log(b);</div></pre></td></tr></table></figure>
<h3 id="三、继承问题"><a href="#三、继承问题" class="headerlink" title="三、继承问题"></a>三、继承问题</h3><p>JavaScript是基于对象和实例的语言，它没有类的概念。所以，要想实现继承，必须熟练应用其<code>prototype</code>机制、函数构造以及<code>call</code>，<code>apply</code>等特殊方法。</p>
<p>可以简单的把<code>prototype</code>看做是一个模板，新创建的自定义对象都是这个模板（<code>prototype</code>）的一个拷贝（实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的<code>__proto__</code>指针，指向原型对象）。</p>
<h4 id="3-1-原型链继承"><a href="#3-1-原型链继承" class="headerlink" title="3.1 原型链继承"></a>3.1 原型链继承</h4><p>为了让子类继承父类的属性（也包括方法），首先需要定义一个构造函数。然后，将父类的新实例赋值给构造函数的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.belong = <span class="string">"human"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();</div></pre></td></tr></table></figure>
<p>简单的说法就是拿父类的实例来充当子类的原型对象。</p>
<p>优点是实现方式相当简单，易于实现。</p>
<p>缺点之一是来自原型对象的引用属性是所有实例共享的，会导致覆盖的属性篡改；二是创建子类实例时，无法向父类构造函数传参。</p>
<h4 id="3-2-借用构造函数"><a href="#3-2-借用构造函数" class="headerlink" title="3.2 借用构造函数"></a>3.2 借用构造函数</h4><p>原型链够简单，但缺点也很明显。于是出现了借用构造函数的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.val = val;</div><div class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">  Super.call(<span class="keyword">this</span>, val);   <span class="comment">// 核心</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub(<span class="number">2</span>);</div><div class="line">sub1.arr.push(<span class="number">2</span>);</div><div class="line">alert(sub1.val);    <span class="comment">// 1</span></div><div class="line">alert(sub2.val);    <span class="comment">// 2</span></div><div class="line"></div><div class="line">alert(sub1.arr);    <span class="comment">// 1, 2</span></div><div class="line">alert(sub2.arr);    <span class="comment">// 1</span></div><div class="line"></div><div class="line">alert(sub1.fun === sub2.fun);   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）。</p>
<p>优点：</p>
<ul>
<li>解决了子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类构造函数传参</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存溢出。</li>
</ul>
<h4 id="3-3-组合继承"><a href="#3-3-组合继承" class="headerlink" title="3.3 组合继承"></a>3.3 组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 只在此处声明基本属性和引用属性</span></div><div class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</div><div class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">//  在此处声明函数</span></div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Super.prototype.fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="comment">//Super.prototype.fun3...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  Super.call(<span class="keyword">this</span>);   <span class="comment">// 核心</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();    <span class="comment">// 核心</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub(<span class="number">2</span>);</div><div class="line">alert(sub1.fun === sub2.fun);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过<code>Super.call(this)</code>;继承父类的基本属性和引用属性并保留能传参的优点；通过<code>Sub.prototype = new Super()</code>;继承父类函数，实现函数复用。</p>
<p>优点：</p>
<ul>
<li>不存在引用属性共享问题</li>
<li>可传参，并且函数可复用</li>
</ul>
<p>缺点：</p>
<ul>
<li>子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的。。。</li>
</ul>
<h4 id="3-4-寄生组合继承"><a href="#3-4-寄生组合继承" class="headerlink" title="3.4 寄生组合继承"></a>3.4 寄生组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   <span class="comment">// 其实只需要原型的一份copy</span></div><div class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  F.prototype = obj;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 只在此处声明基本属性和引用属性</span></div><div class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</div><div class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">//  在此处声明函数</span></div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Super.prototype.fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="comment">//Super.prototype.fun3...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  Super.call(<span class="keyword">this</span>);   <span class="comment">// 核心</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> proto = beget(Super.prototype); <span class="comment">// 核心</span></div><div class="line">proto.constructor = Sub;            <span class="comment">// 核心</span></div><div class="line">Sub.prototype = proto;              <span class="comment">// 核心</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</div><div class="line">alert(sub.val);</div><div class="line">alert(sub.arr);</div></pre></td></tr></table></figure>
<p>用beget(Super.prototype)切掉了原型对象上多余的那份父类实例属性。<br>暂时看起来是集合了上述几种方法的优点，使用起来会稍微麻烦一点。</p>
<h4 id="3-5-关于beget函数"><a href="#3-5-关于beget函数" class="headerlink" title="3.5 关于beget函数"></a>3.5 关于<code>beget</code>函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   <span class="comment">// 其实只需要原型的一份copy</span></div><div class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  F.prototype = obj;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>beget函数的意义在于不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。<br>这个函数其实在IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome中就是<code>Object.create()</code>方法。</p>
<p>此外JS中还有原型式继承和寄生式继承，它们也有明显的缺点，适用于特点的场景，使用不频繁，在此不赘述了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“坑”也就是“陷阱”。由于JavaScript“弱语言”的性质，使得其在使用过程中异常的宽松灵活，但也极为容易“中招”。这些坑往往隐藏着，只有亲自尝试并爬坑，才能在学习与应用的道路上走的一帆风顺。&lt;br&gt;平时积累一些觉得比较有意思或是比较有难度的JavaScript题目，顺便附上理解和心得。既是为了将来的面试做准备，也增强印象以防自己掉进坑里。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlewin.info/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Learning - Promise入门</title>
    <link href="http://littlewin.info/2016/01/20/JavaScript%20Learning%20-%20Promise%E5%85%A5%E9%97%A8/"/>
    <id>http://littlewin.info/2016/01/20/JavaScript Learning - Promise入门/</id>
    <published>2016-01-20T10:15:03.000Z</published>
    <updated>2016-10-24T01:39:20.570Z</updated>
    
    <content type="html"><![CDATA[<p>在很多需要与数据打交道的场合下，我们会遇到很多异步的情况,在异步操作的时候，我们还需要处理成功和失败两种情况，并且成功的时候，还可能需要把结果传递给下一个Ajax调用，从而形成”函数嵌套”的情况。callback是编写Javascript异步代码最最最简单的机制。可用这种原始的callback必须以牺牲控制流、异常处理和函数语义为代价。<br><a id="more"></a></p>
<h3 id="具体实现的库"><a href="#具体实现的库" class="headerlink" title="具体实现的库"></a>具体实现的库</h3><h4 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h4><p>只需要在浏览器中加载Polyfill类库，就能使用IE10等或者还没有提供对Promise支持的浏览器中使用Promise里规定的方法。</p>
<ul>
<li><a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="external">jakearchibald/es6-promise</a>：一个兼容 ES6 Promises 的Polyfill类库。它基于RSVP.js这个兼容Promises/A+ 的类库，它只是RSVP.js的一个子集，只实现了Promises 规定的API。</li>
<li><a href="https://github.com/yahoo/ypromise" target="_blank" rel="external">yahoo/ypromise</a>：这是一个独立版本的YUI的Promise Polyfill，具有和ES6 Promises的兼容性。</li>
<li><a href="https://github.com/getify/native-promise-only/" target="_blank" rel="external">getify/native-promise-only</a>：以作为ES6 Promises的polyfill为目的的类库，它严格按照ES6 Promises的规范设计，没有添加在规范中没有定义的功能。如果运行环境有原生的Promise支持的话，则优先使用原生的Promise支持。</li>
</ul>
<h4 id="扩展类库"><a href="#扩展类库" class="headerlink" title="扩展类库"></a>扩展类库</h4><p>Promise扩展类库除了实现了Promise中定义的规范之外，还增加了自己独自定义的功能。</p>
<ul>
<li><a href="https://github.com/then/promise" target="_blank" rel="external">then/promise</a>: a super set of ES6 Promises designed to have readable, performant code and to provide just the extensions that are absolutely necessary for using promises today.</li>
<li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">petkaantonov/bluebird</a>: 这个类库除了兼容 Promise 规范之外，还扩展了取消promise对象的运行，取得promise的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。</li>
<li><a href="https://github.com/cujojs/when" target="_blank" rel="external">when</a>: 大小很小,node和浏览器环境下都可以使用。</li>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">q</a>: 类库Q实现了Promises和Deferreds等规范。它自2009年开始开发，还提供了面向Node.js的文件IO API Q-IO等，是一个在很多场景下都能用得到的类库。</li>
</ul>
<h3 id="编写Promise代码"><a href="#编写Promise代码" class="headerlink" title="编写Promise代码"></a>编写Promise代码</h3><h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><ul>
<li>使用<code>new Promise(fn)</code>返回一个Promise对象</li>
<li>在在<code>fn</code>中制定异步等处理:<br>处理结果正常的情况，调用resolve(处理结果值)<br>处理结果错误的话,调用reject(Error对象)</li>
</ul>
<h4 id="创建Promise对象"><a href="#创建Promise对象" class="headerlink" title="创建Promise对象"></a>创建Promise对象</h4><p>最基本的情况，是使用<code>new Promise()</code>来创建Promise对象。也可以使用<code>Promise.resolve(value)</code>代替<code>new Promise()</code>快捷方法。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  reslove(<span class="number">42</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="Thenable"><a href="#Thenable" class="headerlink" title="Thenable"></a>Thenable</h4><p>就像我们有时称具有<code>.length</code>方法的非数组对象为Array like一样，thenable指的是一个具有<code>.then</code>方法的对象。</p>
<p>这种将thenable对象转换为promise对象的机制要求thenable对象所拥有的<code>then</code>方法应该和Promise所拥有的<code>then</code>方法具有同样的功能和处理过程，在将thenable对象转换为promise对象的时候，还会巧妙的利用thenable对象原来具有的<code>then</code>方法。变成了promise对象的话，就能直接使用<code>then</code>或者<code>catch</code>, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>));<span class="comment">// =&gt; promise对象</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的是:即使一个对象具有<code>.then</code>方法，也不一定就能作为ES6 Promises对象使用。比如jQuery的Defeered Object的then方法机制与Promise不同。</p>
<p>其实在Promise里可以将任意个方法连在一起作为一个方法链（method chain），比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="comment">// task A</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params">vaue</span>)</span>&#123;</div><div class="line">  <span class="comment">// task B</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><p><code>Promise.reject(error)</code>是和<code>Promise.resolve(value)</code>类似的静态方法，是<code>new Promise()</code>方法的快捷方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错了"</span>));</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错了"</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise的同步or异步调用"><a href="#Promise的同步or异步调用" class="headerlink" title="Promise的同步or异步调用"></a>Promise的同步or异步调用</h4><p>先看下面这段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReady</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> readyState = <span class="built_in">document</span>.readyState;</div><div class="line">  <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">    fn();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, fn);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">onReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>);</div></pre></td></tr></table></figure>
<p>这段代码会根据执行时DOM是否已经装载完毕来决定是对回调函数进行同步调用还是异步调用。这实际上会让我们的代码是同步还是一部产生混淆，所以为了解决这个问题，我们应该统一使用异步调用的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReady</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> readyState = <span class="built_in">document</span>.readyState;</div><div class="line">  <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">    setTimeout(fn, <span class="number">0</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, fn);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">onReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>);</div></pre></td></tr></table></figure>
<p>我们看到的<code>promise.then</code>也属于此类，为了避免上述中同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定Promise只能使用异步调用方式 ，修改代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReadyPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> readyState = <span class="built_in">document</span>.readyState;</div><div class="line">    <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">        resolve();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, resolve);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">onReadyPromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>);</div></pre></td></tr></table></figure>
<h4 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise#catch"></a>Promise#catch</h4><p>链式上的<code>catch</code>会捕获前面所有<code>then</code>的错误情况。其实这也是个语法糖:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"message"</span>));</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"message"</span>));</div><div class="line">promise.then(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>提倡使用<code>catch</code>的原因还有一个就是: 使用<code>promise.then(onFulfilled, onRejected)</code>的话, 在<code>onFulfilled</code>中发生异常的话，在<code>onRejected</code>中是捕获不到这个异常的。</p>
<p>然而实际上不管是<code>then</code>还是<code>catch</code>方法调用，都返回了一个新的promise对象。</p>
<h4 id="Promise-chain"><a href="#Promise-chain" class="headerlink" title="Promise chain"></a>Promise chain</h4><p>通过<code>then</code>方法，我们可以将代码写成方法链的形式。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Task A"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Task B"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Catch Error: A or B"</span>, error);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finalTask</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Final Task"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</div><div class="line">promise</div><div class="line">  .then(taskA)</div><div class="line">  .then(taskB)</div><div class="line">  .catch(onRejected)</div><div class="line">  .then(finalTask);</div></pre></td></tr></table></figure>
<p>chain的时候，如何传递参数？答案非常简单，那就是在 Task A 中 return 的返回值，会在 Task B 执行时传给它。因为return的值会由 Promise.resolve(return的返回值)进行相应的包装处理。</p>
<h3 id="多个Promise对象完成后统一处理"><a href="#多个Promise对象完成后统一处理" class="headerlink" title="多个Promise对象完成后统一处理"></a>多个Promise对象完成后统一处理</h3><h4 id="通过回调方式来进行多个异步调用"><a href="#通过回调方式来进行多个异步调用" class="headerlink" title="通过回调方式来进行多个异步调用"></a>通过回调方式来进行多个异步调用</h4><p>看代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURLCallback</span>(<span class="params">URL, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">  req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">      callback(<span class="literal">null</span>, req.responseText);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText), req.response);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    callback(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">  &#125;;</div><div class="line">  req.send();</div><div class="line">&#125;</div><div class="line"><span class="comment">// &lt;1&gt; 对JSON数据进行安全的解析</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonParse</span>(<span class="params">callback, error, value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (error) &#123;</div><div class="line">    callback(error, value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(value);</div><div class="line">      callback(<span class="literal">null</span>, result);</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      callback(e, value);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// &lt;2&gt; 发送XHR请求</span></div><div class="line"><span class="keyword">var</span> request = &#123;</div><div class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURLCallback(<span class="string">'http://azu.github.io/promises-book/json/comment.json'</span>, jsonParse.bind(<span class="literal">null</span>, callback));</div><div class="line">  &#125;,</div><div class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURLCallback(<span class="string">'http://azu.github.io/promises-book/json/people.json'</span>, jsonParse.bind(<span class="literal">null</span>, callback));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// &lt;3&gt; 启动多个XHR请求，当所有请求返回时调用callback</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">allRequest</span>(<span class="params">requests, callback, results</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (requests.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> callback(<span class="literal">null</span>, results);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> req = requests.shift();</div><div class="line">  req(<span class="function"><span class="keyword">function</span> (<span class="params">error, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">      callback(error, value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      results.push(value);</div><div class="line">      allRequest(requests, callback, results);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  allRequest([request.comment, request.people], callback, []);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 运行的例子</span></div><div class="line">main(<span class="function"><span class="keyword">function</span>(<span class="params">error, results</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(error)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(error);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(results);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>缺点:</p>
<ul>
<li>需要显示进行异常处理</li>
<li>为了不让嵌套层次太深，需要一个对request进行处理的函数</li>
<li>到处都是回调函数</li>
</ul>
<h4 id="使用Promise-then同时处理多个异步请求"><a href="#使用Promise-then同时处理多个异步请求" class="headerlink" title="使用Promise#then同时处理多个异步请求"></a>使用Promise#then同时处理多个异步请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">        resolve(req.responseText);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">    &#125;;</div><div class="line">    req.send();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> request = &#123;</div><div class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/comment.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;,</div><div class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/people.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</div><div class="line">    results.push(value);</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// [] 用来保存初始化的值</span></div><div class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</div><div class="line">  <span class="keyword">return</span> request.comment().then(pushValue).then(request.people).then(pushValue);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 运行的例子</span></div><div class="line">main().then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种方法也不是我们期望的，和上面的回调函数风格相比:</p>
<ul>
<li>可以直接使用<code>JSON.parse</code>函数</li>
<li>函数<code>main()</code>返回promise对象</li>
<li>错误处理的地方直接对返回的promise对象进行处理</li>
</ul>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p><code>Promise.all</code>接收一个promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用<code>.then</code>方法。比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">        resolve(req.responseText);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">    &#125;;</div><div class="line">    req.send();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> request = &#123;</div><div class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/comment.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;,</div><div class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/people.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([request.comment(), request.people()]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 运行示例</span></div><div class="line">main().then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样的优点是:</p>
<ul>
<li>main中的处理流程非常清晰</li>
<li>Promise.all接收promise对象组成的数组作为参数</li>
</ul>
<p>Promise数组是同时开始执行的，then调用参数的结果之中的results顺序和传递的数组的顺序一致。并且调用then的时间由最后一个完成的异步操作决定。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>它的使用方法和Promise.all一样，接收一个promise对象数组为参数。与all的区别就是：race只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。但是Promise中的数组也还是会继续执行。但是then只接受第一个完成的Promise返回对象。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://www.infoq.com/cn/news/2011/09/js-promise/" target="_blank" rel="external">JavaScript异步编程的Promise模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多需要与数据打交道的场合下，我们会遇到很多异步的情况,在异步操作的时候，我们还需要处理成功和失败两种情况，并且成功的时候，还可能需要把结果传递给下一个Ajax调用，从而形成”函数嵌套”的情况。callback是编写Javascript异步代码最最最简单的机制。可用这种原始的callback必须以牺牲控制流、异常处理和函数语义为代价。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlewin.info/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>WEB跨域的实现</title>
    <link href="http://littlewin.info/2016/01/08/WEB%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://littlewin.info/2016/01/08/WEB跨域的实现/</id>
    <published>2016-01-08T03:27:43.000Z</published>
    <updated>2016-10-10T11:51:06.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-10-10/47252019.jpg" width="60%" height="60%"></p>
<p>在开发现代WEB应用时，常常会遇到以下情形：</p>
<ol>
<li>客户端使用JavaScript</li>
<li>需要跨域加载服务</li>
<li>如果采用常规的XMLHttpRequest方法，最终会在浏览器终端里显示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load [http://external.service/](http://external.service/).</div><div class="line">No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</div><div class="line">Origin &apos;[http://my.app](http://my.app/)&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
</li>
</ol>
<p>每当WEB应用需要跨域加载API时，往往会遇到这种错误，本文就以此问题入手，记录下WEB跨域的学习笔记。</p>
<a id="more"></a>
<h3 id="同源策略（Same-origin-policy）"><a href="#同源策略（Same-origin-policy）" class="headerlink" title="同源策略（Same origin policy）"></a>同源策略（Same origin policy）</h3><p>同源策略（SOP）是一种WEB安全约定，它的主要目的是抑制来自不同域的文件的相互影响。</p>
<p>一个页面的源由<strong>协议</strong>、<strong>域名</strong>、<strong>端口号</strong>决定，举例，本博客的源地址是（’http’, ‘littlewin.info’, 80）。同源之间的资源文件可以互相访问。如果页面A和页面B拥有相同的源，A页面上的JavaScript代码可以使用HTTP请求访问B的资源，操作B的DOM结构，甚至设置B的cookies。需要注意的是，源是由页面的地址定义的，一个通过CDN引用的JavaScript文件是运行在包含此文件的HTML页面上，而非它的引用地址上。</p>
<p>对于特定的跨域HTTP请求，SOP规定以下一般规则：允许跨域写，禁止跨域读取。这意味着如果A和C是不同的源，A发送的HTTP请求会由C正确地接收（这些就是“写”），但是A中的脚本将无法读取任何数据–甚至来自C返回的响应代码。跨域“读取”会被浏览器屏蔽，导致出现上面的错误。换句话说，<strong>SOP不阻止攻击者向他们源写数据，它只是不允许他们读取来自你的域的数据（cookie, localStorage 或其他）或利用接收到的响应来做任何事。</strong></p>
<p>SOP策略是是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。</p>
<h3 id="执行跨域请求"><a href="#执行跨域请求" class="headerlink" title="执行跨域请求"></a>执行跨域请求</h3><p>然而，有时你必须执行跨域请求，而这需要一些额外的操作。合法的跨域请求示例：</p>
<ul>
<li>你必须集成第三方服务（如一个论坛），有一个REST API驻留在不同源。</li>
<li>服务器端服务托管在不同的（子）域。</li>
<li>客户端逻辑来自不同源而不是服务器端服务端点。</li>
<li>…</li>
</ul>
<p>根据应用的跨服务器规模，可以采用多个选项来启用跨域请求。本文将讨论可能的解决方案：JSONP, 使用服务器端代理和CORS。</p>
<p>当然还有其他选择，使用较广泛的的技术是使用iframes和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a>，这些不在本文讨论。</p>
<h3 id="跨域请求示例"><a href="#跨域请求示例" class="headerlink" title="跨域请求示例"></a>跨域请求示例</h3><p>有2个网站，一个网站在源（‘http’,’localhost’,3000），另一个在（‘http’,’localhost’,3001）。它们是不同的源，所以3000请求3001被认为是跨域请求并被浏览器默认屏蔽。</p>
<p>考虑以下场景 - A域的页面想要执行一个GET请求到B域的页面：</p>
<p>浏览器向服务器端发送请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div></pre></td></tr></table></figure>
<p>服务器端返回响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line">Content-Length: 57</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the server&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而在接收到响应，浏览器屏蔽响应进一步传播，并显示跨域请求错误，如上所示。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JavaScript Object Notation with Padding（JSONP）是一种执行跨域请求的方法，通过利用HTML页面的script标签可以加载来自不同域的API。但这种方式有一些重大的问题：</p>
<ul>
<li>JSONP只能用来执行跨域GET请求。</li>
<li>服务器必须明确地支持JSONP请求。</li>
<li>你必须绝对地信任服务器提供的JSONP响应。</li>
<li>如果服务器被盗用，JSONP可以使你的网站暴露大量的<a href="http://security.stackexchange.com/questions/23438/security-risks-with-jsonp" target="_blank" rel="external">安全漏洞</a>。</li>
</ul>
<p>JSONP实现原理是 - <code>&lt;script&gt;</code>标签可以有来自不同域的资源，当浏览器解析<code>&lt;script&gt;</code>标签，它会GET请求脚本内容（来自任何源）并在当前的页面中执行。通常，服务器会返回HTML或一些XML或JSON数据。有时向一个启用JSONP的服务器请求时，它会返回一个脚本块，这个脚本块执行一个在页面中定义好的回调函数，并提供参数。以下举例：</p>
<p>源3000的页面想要获取存储在源3001的资源。源3000页面包含下面的script标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">'http://localhost:3001?callback=myCallbackFunction'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>当浏览器解析这个script标签，它将正常的发出GET请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /?callback=myCallbackFunction HTTP/1.1</div></pre></td></tr></table></figure>
<p>服务器没法返回原生JSON，而是返回一个脚本块，包含函数的调用，函数名在URL中指定，输出的数据作为参数传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/javascript</div><div class="line"></div><div class="line">myCallbackFunction(&#123;&apos;response&apos;: &apos;hello world from JSONP!&apos;&#125;);</div></pre></td></tr></table></figure>
<p>这个脚本块在浏览器接收到后就立即被执行，当前页面定义了回调函数，它使用返回的数据作为参数。</p>
<p>Tips：</p>
<ul>
<li>由于JSONP的工作原理是通过一个script标签加载GET请求，因此它只支持跨域的HTTP GET请求。如果你想使用其他的HTTP请求（像POST, PUT或DELETE），就不能使用JSONP方法。</li>
<li>这个方法要求你必须完全地信任服务器。这个服务器可能被盗用，并返回任意代码，将在你的页面中执行（访问你的网站cookies, localStorage等等）。</li>
</ul>
<h3 id="服务器端代理"><a href="#服务器端代理" class="headerlink" title="服务器端代理"></a>服务器端代理</h3><p>这种绕过同源策略执行而跨域请求的方法没有任何跨域操作，而是使用一个代理服务器在后端访问外部服务，并把结果返回给客户端。请求代码和代理服务器是在同一个域中，因此并不违反同源策略。</p>
<p>这种机制不需要改变现有的服务器代码，它需要服务器端采用代理服务，且在当前域中在浏览器中运行JavaScript代码。</p>
<p>这次不直接向3001域发送GET请求，而是向自己域的代理服务器发送请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /proxy?urlToFetch=http%3A%2F%2Flocalhost%3A3001 HTTP/1.1</div></pre></td></tr></table></figure></p>
<p>服务器将执行实际的GET请求外部服务。服务器端代码可以正常的执行跨域请求而不会发生错误，因此可以成功的调用。代理服务将结果输送给客户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the server, proxy style!&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这种方法也有一些严重的缺点。如果第三方服务使用cookies进行身份验证，那么你就不能使用这种方法。本地的JavaScript代码是不能访问外部的域的cookies并且也不能发送cookies给你的代理服务，所以包含用户验证信息的cookies无法提供给第三方服务。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>上述两种方法或多或少存在一些“hack”的感觉，实际上都是绕过浏览器的安全机制而实现。</p>
<p>HTML5引入了一个标准的跨域请求方法 -  <a href="http://www.w3.org/TR/cors/" target="_blank" rel="external">Cross-Origin Resource Sharing</a></p>
<p>CORS为服务器提供了一个准入机制，它告诉浏览器域A读取请求自域B的数据是可以的。这种方法是通过在http响应头中包含一个新的Access-Control-Allow-Origin属性值。当浏览器接收到跨域的响应时，它会检查CORS头。如果响应头中指定的源匹配当前源，它允许读取跨域访问的响应。否则，会得到上述错误信息。</p>
<p>像往常一样进行跨域请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div></pre></td></tr></table></figure>
<p>源3001的服务器检查是否这个源可以访问数据，并在响应中增加额外的Access-Control-Allow-Origin头，列出请求源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Access-Control-Allow-Origin: http://localhost:3000</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line">Content-Length: 62</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the CORS server&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当浏览器接收到响应时它比较请求源（3000）和列在Access-Control-Allow-Origin头的源（也是3000）。由于请求源出现在Access-Control-Allow-Origin值中，浏览器允许源3000的请求执行响应。</p>
<p>同样的，这种方法有一些局限性。例如老版本的IE只能<a href="http://caniuse.com/#search=CORS" target="_blank" rel="external">部分支持CORS</a>。 同时，对于非简单请求，在正式通信之前，增加了一次HTTP查询请求（参考：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a>）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比以上三种方法 - </p>
<p>JSONP只支持GET请求，服务器代理和CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。Proxy方式，通过强大的后端应用可以提供更灵活更能发挥想象力的服务。CORS是目前W3C支持的方式，在新浏览器上体验更好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xpot0.com1.z0.glb.clouddn.com/16-10-10/47252019.jpg&quot; width=&quot;60%&quot; height=&quot;60%&quot;&gt;&lt;/p&gt;
&lt;p&gt;在开发现代WEB应用时，常常会遇到以下情形：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端使用JavaScript&lt;/li&gt;
&lt;li&gt;需要跨域加载服务&lt;/li&gt;
&lt;li&gt;如果采用常规的XMLHttpRequest方法，最终会在浏览器终端里显示&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;XMLHttpRequest cannot load [http://external.service/](http://external.service/).&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;No &amp;apos;Access-Control-Allow-Origin&amp;apos; header is present on the requested resource.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Origin &amp;apos;[http://my.app](http://my.app/)&amp;apos; is therefore not allowed access.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每当WEB应用需要跨域加载API时，往往会遇到这种错误，本文就以此问题入手，记录下WEB跨域的学习笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlewin.info/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习之ARC</title>
    <link href="http://littlewin.info/2016/01/03/Objective-C%E5%AD%A6%E4%B9%A0%E4%B9%8BARC/"/>
    <id>http://littlewin.info/2016/01/03/Objective-C学习之ARC/</id>
    <published>2016-01-03T13:27:33.000Z</published>
    <updated>2016-09-06T11:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理在程序开发中有着至关重要的作用，基本上每个C系的程序员都会遇到与内存相关的错误，这种错误是灾难性的。Java或脚本语言的内存管理是自动进行的，就像父母会给孩子打扫房间一样。对于C系程序开发，我们必须合理分配内存，在内存结束使用后释放它们，避免内存泄漏（leak memory）。</p>
<a id="more"></a> 
<h5 id="iOS内存管理机制"><a href="#iOS内存管理机制" class="headerlink" title="iOS内存管理机制"></a>iOS内存管理机制</h5><p>iOS开发中，内存中的对象主要有两类，一类是值类型，比如<code>int</code>、<code>float</code>、<code>struct</code>等基本数据类型；另一类是引用类型，也就是继承自NSObject类的所有的OC对象。</p>
<p>值类型会被放入栈中，他们依次紧密排列，在内存中占有一块连续的内存空间，遵循先进后出的原则。栈内存中的值类型系统会随着其生命周期自动管理。</p>
<p>引用类型会被放到堆中，当给对象分配内存空间时，会随机的从内存当中开辟空间，设备内存使有限的，需要我们在释放对象后将其占据的内存归还堆空间，使之可以再被利用。</p>
<p>在Apple引入自动引用计数（Automatic Reference Counting, ARC）之前，应用只能通过手动引用计数（Mannul Reference Counting, MRC）来管理内存，具体的原则也很简单</p>
<blockquote>
<p>如果需要持有一个对象，那么对其发送<code>retain</code>如果之后不再使用该对象，那么需要对其发送<code>release</code>（或者<code>autorealse</code>）。每一次对<code>retain</code>，<code>alloc</code>或者<code>new</code>的调用，需要对应一次<code>release</code>或<code>autorealse</code>调用。</p>
</blockquote>
<p>大多数情况下，可以依靠ARC来自动的完成需要的内存管理功能。但是，理解其工作原理，可以便于我们调试应用或对一些场景做特殊处理。</p>
<h5 id="指针变量与对象所有权"><a href="#指针变量与对象所有权" class="headerlink" title="指针变量与对象所有权"></a>指针变量与对象所有权</h5><blockquote>
<p>当某个方法（或函数）有一个指向某个对象的局部变量时，可以称该变量拥有该变量所指向的对象。<br>当某个对象有一个指向其他对象的实例变量时，可以称该对象拥有该实例变量所指向的对象。</p>
</blockquote>
<p>例如<br><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-1-3/76239862.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject</div><div class="line">&#123;</div><div class="line">    NSString *newString;</div><div class="line">&#125;</div><div class="line">@property (nonatomic, retain) NSString *newString;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NewClass *newClass = [NewClass alloc];</div><div class="line">[newClass init];</div><div class="line">newClass.newString = @&quot;littlewin&quot;</div></pre></td></tr></table></figure>
<p><code>newClass</code>对象拥有其实例变量<code>newString</code>所指向的对象<code>@&quot;littlewin&quot;</code>。</p>
<p>对象的所有权可以帮助我们决定释放对象和回收内存的时机。</p>
<blockquote>
<p>如果某个对象没有拥有者，就应该将其释放掉。<br>如果某个对象有一个或多个拥有者，就必须保留不能释放。</p>
</blockquote>
<p>下列情况会使对象失去拥有者：</p>
<ul>
<li>当指针变量指向另一个对象时<br><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-1-3/11277658.jpg" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理在程序开发中有着至关重要的作用，基本上每个C系的程序员都会遇到与内存相关的错误，这种错误是灾难性的。Java或脚本语言的内存管理是自动进行的，就像父母会给孩子打扫房间一样。对于C系程序开发，我们必须合理分配内存，在内存结束使用后释放它们，避免内存泄漏（leak memory）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://littlewin.info/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://littlewin.info/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习之OOP</title>
    <link href="http://littlewin.info/2016/01/01/Objective-C%E5%AD%A6%E4%B9%A0%E4%B9%8BOOP/"/>
    <id>http://littlewin.info/2016/01/01/Objective-C学习之OOP/</id>
    <published>2016-01-01T07:02:41.000Z</published>
    <updated>2016-09-06T11:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>最近元旦无事在家休息，将这半年来所学记录于此。以后无论事情再多，也要力争在短周期内通过blog上update自己的学习记录和心得，一来督促自己，二来方便日后查阅。</em></p>
<p>开发iOS应用需要使用Objective-C语言和Cocoa Touch框架。Objective-C源自C语言，是C语言的扩展。Cocoa Touch框架则是一个Objective-C类的集合。<br><a id="more"></a> </p>
<h5 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h5><p>Objective-C的类与其他OOP语言基本类似，是一种表示对象类型的结构体。对象通过它隶属的类来获取自身的各种信息，尤其是执行每个操作所要运行的代码。<br><code>@interface</code>指令将类所提供的数据结构成员告知Objective-C编译器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject  </div><div class="line">&#123;</div><div class="line">//fill in instance variable</div><div class="line">&#125;</div><div class="line">//fill in method declaration</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><code>@implementation</code>部分提供各个数据接口的功能代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@implementation NewClass</div><div class="line">//fill in implementation</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>在Objective-C中，几乎所有的类都是NSObject类的子类，因此，可以将这些类也看为对象，对象能够接收的消息列表是保存在它所对应的类中。每一个对象都有一个名为 isa 的指针，指向该对象的类。</p>
<p>NSObject 就是一个包含 isa 指针的结构体，它的定义如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject  &#123; </div><div class="line">    Class isa; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类是元类(metaclass)的实例，元类的isa指针指向根元类（root metaclass），根元类 (root metaclass) 本身的 isa 指针指向自己，形成一个闭环的继承路径。<br><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-1-1/48692569.jpg" alt=""><br>对象是类的实例，其本身是分配在内存中的一块数据。对象是有生命周期的，首先被创建，然后接受消息，最后在不需要时被释放。向类发alloc消息，会在内存中创建对象并返回对象指针。对新创建的对象，必须先向其发送一个初始化消息，然后它才能正常工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NewClass *newClass = [NewClass alloc];</div><div class="line">[newClass init];</div></pre></td></tr></table></figure></p>
<p>在对象完成使命后，可以要求程序释放对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newClass=nil;</div></pre></td></tr></table></figure></p>
<h5 id="实例变量和属性"><a href="#实例变量和属性" class="headerlink" title="实例变量和属性"></a>实例变量和属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject</div><div class="line">&#123;</div><div class="line">    NSString *newString;</div><div class="line">&#125;</div><div class="line">@property (nonatomic, retain) NSString *newString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>声明类的实例变量时，需要将相应的声明写在花括号里，并紧跟在类声明的后面。为类添加实例变量后，还要定义存取方法（accessor method），否则无法访问对象的实例变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)setNewString:(NSString *)str;</div><div class="line">- (NSString *)newString;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)setNewString:(NSString *)str</div><div class="line">&#123;</div><div class="line">    _newString = str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)newString</div><div class="line">&#123;</div><div class="line">    return _newString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@Property</code>是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器。</p>
<p>它们的区别有以下几点</p>
<ul>
<li>直接操作实例变量明显更快。因为不需要经过OC的方法分发，直接从内存中读取。</li>
<li>直接写实例变量会绕过属性的内存管理声明，假如你的属性声明为 <code>copy</code>，直接写入它的实例变量将不会产生copy操作。</li>
<li>直接操作实例变量，不会发送KVO通知。</li>
<li>操作属性方便调试，你可以给get/set方法加断点，就能知道谁在什么时候进行了读写操作。</li>
</ul>
<h5 id="类方法和实例方法"><a href="#类方法和实例方法" class="headerlink" title="类方法和实例方法"></a>类方法和实例方法</h5><p>类方法的作用通常是创建对象，或者获取类的某些全局属性。<strong>类方法不会作用在在对象上，也不能存取实例变量</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (void)toNewString</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;this is a class method of NewString&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实例方法则用来操作类的对象（对象有时也可称为类的一个实例）例如上述存取方法。</p>
<p>在创建一个NewClass对象时，首先向NewClass类发送<code>alloc</code>（类方法）消息，然后向使用alloc方法创建的对象newClass发送<code>init</code>（实例方法）消息。</p>
<h5 id="继承与复合"><a href="#继承与复合" class="headerlink" title="继承与复合"></a>继承与复合</h5><p>继承（is-a关系）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject</div></pre></td></tr></table></figure></p>
<p>Objective-c不支持多继承。<br>Objective-c支持重写方法，同时仍然调用超类的实现方式，这时需要使用<code>super</code>关键词来调用父类方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[super init]；</div></pre></td></tr></table></figure></p>
<p>复合（has-a关系）<br>在objective-c中，复合是通过包含作为实例变量的对象指针实现的，如NewClass可以包含newString和oldString。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject </div><div class="line">&#123; </div><div class="line">    NSString *newString; </div><div class="line">    NSString *oldString;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>严格来讲，只有对象间的组合才能叫复合，而基本类型都被认为是对象的一部分。</p>
<h5 id="一些没提到的关键字"><a href="#一些没提到的关键字" class="headerlink" title="一些没提到的关键字"></a>一些没提到的关键字</h5><ul>
<li><code>self</code> 与 <code>super</code><br><code>self</code> 是一个隐含的指针，指向接收消息的对象的指针。<br><code>super</code>既不是参数也不是实例变量。向<code>super</code>发消息时，实际上是在请求Objective-C向该类的超类发送消息。如果超类中没有定义的消息，Objective-C将按照继承的通常规则在继承链中查找。例如<code>[super init]</code>用于向超类的<code>init</code>方法发送消息。</li>
<li><code>id</code><br><code>id</code>是指向Objective-C类对象的指针，它可以声明为任何类对象的指针，当在Objective-C中使用id时，编译器会假定你知道，<code>id</code>指向哪个类的对象。与<code>void*</code>是不同的是，<code>void*</code>编译器不知道也不假定指向任何类型的指针。</li>
<li><code>nil</code><br>定义为一个常量，如果一个指针的值为<code>nil</code>,代表这个指针没有指向任何对象。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;最近元旦无事在家休息，将这半年来所学记录于此。以后无论事情再多，也要力争在短周期内通过blog上update自己的学习记录和心得，一来督促自己，二来方便日后查阅。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;开发iOS应用需要使用Objective-C语言和Cocoa Touch框架。Objective-C源自C语言，是C语言的扩展。Cocoa Touch框架则是一个Objective-C类的集合。&lt;br&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://littlewin.info/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://littlewin.info/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Learning - 回调函数的理解和使用</title>
    <link href="http://littlewin.info/2015/12/06/JavaScript%20Learning%20-%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://littlewin.info/2015/12/06/JavaScript Learning - 回调函数的理解和使用/</id>
    <published>2015-12-06T06:35:20.000Z</published>
    <updated>2016-09-30T06:37:56.723Z</updated>
    
    <content type="html"><![CDATA[<p>回调函数主要体现在函数式编程的编程方式，即使用函数作为参数。函数式编程在编程的进阶领域会有充分的体现，需要进行一段时间的学习和练习。<br>所幸函数式编程在很多语言规范里都有明确的定义和解释，而函数式编程中主要用到的方法就是回调函数。回调函数的在进阶的JavaScript中常有用到，但其实有一些理解之后，用法和传入普通参数并无太大差异。<br><a id="more"></a></p>
<h3 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a>1. 回调函数</h3><blockquote>
<p>回调函数，是将一个函数作为参数传入另一个函数，并且在这个函数中进行调用的编程方式。回调函数本身是一种编程模式，因此使用回调函数的方式也被称为回调模式。</p>
</blockquote>
<p>先来一个简单的jQuery例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#btn_1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">"Btn 1 Clicked"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>匿名函数作为参数传入click函数，click函数执行时会执行此函数，这种例子在JavaScript和jQuery种经常被用到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friends = [<span class="string">"Mike"</span>, <span class="string">"Stacy"</span>, <span class="string">"Andy"</span>, <span class="string">"Rick"</span>];</div><div class="line">friends.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">eachName, index</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(index + <span class="number">1</span> + <span class="string">". "</span> + eachName); <span class="comment">// 1. Mike, 2. Stacy, 3. Andy, 4. Rick​</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>以上两个例子都是直接传递匿名函数去别的函数进行调用的回调方式，在更复杂的例子之前，有必要先了解一下回调函数的执行原理。</p>
<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p>当使用回调函数时，通过参数传递的是函数的定义，而不是函数的执行功能。简而言之，我们传递的是<code>callback</code>，而不是<code>callback()</code>。<br>因此作为函数定义，回调函数可以在另外一个函数中的任何执行时刻被调用。</p>
<p>此外，通过参数传递的回调函数会在另一个函数体内被调用执行，类似于回调函数的定义位于另一个函数内，因此，回调函数本质上是闭包。而闭包可以访问包含函数的作用范围，因此回调函数可以访问包含函数的变量，即使这个变量来自全局作用域。</p>
<h3 id="3-实现回调函数"><a href="#3-实现回调函数" class="headerlink" title="3. 实现回调函数"></a>3. 实现回调函数</h3><p>回调函数的使用不算太难，但在实现方面需要注意一些原则。</p>
<ul>
<li><strong>使用命名或匿名函数作为回调</strong></li>
</ul>
<p>上面两个例子使用匿名函数作为回调，声明命名函数，并传递函数名作为参数也可以实现回调。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">var</span> allUserData = [];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">logStuff</span> (<span class="params">userData</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> userData === <span class="string">"string"</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">console</span>.log(userData);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> userData === <span class="string">"object"</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> userData) &#123;</div><div class="line">        <span class="built_in">console</span>.log(item + <span class="string">": "</span> + userData[item]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ​<span class="function"><span class="keyword">function</span> <span class="title">getInput</span> (<span class="params">options, callback</span>) </span>&#123;</div><div class="line">    allUserData.push (options);</div><div class="line">    callback (options);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  getInput (&#123;name:<span class="string">"Rich"</span>, speciality:<span class="string">"JavaScript"</span>&#125;, logStuff);</div><div class="line">  <span class="comment">// name: Rich​</span></div><div class="line">​  <span class="comment">// speciality: JavaScript</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>在回调函数中使用参数</strong></li>
</ul>
<p>回调函数在执行过程中是作为一个常规的函数，因此可以向其传入参数。可以将任何包含函数的属性（或全局属性）传入回调函数的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量</span></div><div class="line"><span class="keyword">var</span> generalLastName = <span class="string">"Clinton"</span>;</div><div class="line"></div><div class="line">​<span class="function"><span class="keyword">function</span> <span class="title">getInput</span> (<span class="params">options, callback</span>) </span>&#123;</div><div class="line">  allUserData.push (options);</div><div class="line">  ​<span class="comment">// 向回调函数传入全局变量generalLastName和局部变量options</span></div><div class="line">  callback (generalLastName, options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>先定义，再调用</strong></li>
</ul>
<p>在执行回调函数前先对其做一些检查是很较好的编程习惯<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> generalLastName = <span class="string">"Clinton"</span>;</div><div class="line"></div><div class="line">​<span class="function"><span class="keyword">function</span> <span class="title">getInput</span> (<span class="params">options, callback</span>) </span>&#123;</div><div class="line">  allUserData.push (options);</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">"function"</span>) &#123;</div><div class="line">    callback (generalLastName, options);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有检查，并且传入参数不当，运行过程中会导致程序出错。</p>
<ul>
<li><strong>回调函数使用this对象</strong></li>
</ul>
<p>当回调函数使用<code>this</code>对象时，需要注意<code>this</code>指代的上下文环境。之前在讨论<code>apply</code>和<code>call</code>时有个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> clientData = &#123;</div><div class="line">  id: <span class="number">094545</span>,</div><div class="line">  fullName: <span class="string">"Not Set"</span>,</div><div class="line">  setUserName: <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.fullName = firstName + <span class="string">" "</span> + lastName;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInput</span> (<span class="params">firstName, lastName, callback</span>) </span>&#123;</div><div class="line">  callback(firstName, lastName);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getUserInput (<span class="string">"Barack"</span>, <span class="string">"Obama"</span>, clientData.setUserName);</div><div class="line"><span class="built_in">console</span>.log (clientData.fullName); <span class="comment">// "Not Set"</span></div></pre></td></tr></table></figure>
<p>下面代码将不会修改<code>clientData</code>的<code>fullName</code>属性，而是将操作执行到全局作用域，因为<code>getUserInput</code>函数定义在了全局域，如果要修改回调函数的执行上下文，就要用到<code>apply</code>和<code>call</code>方法。<br>重新定义<code>getUserInput</code>函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInput</span> (<span class="params">firstName, lastName, callback, callbackObj</span>) </span>&#123;</div><div class="line">  callback.apply (callbackObj, [firstName, lastName]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getUserInput (<span class="string">"Barack"</span>, <span class="string">"Obama"</span>, clientData.setUserName, clientData);</div><div class="line"><span class="built_in">console</span>.log (clientData.fullName); <span class="comment">// Barack Obama​</span></div></pre></td></tr></table></figure></p>
<ul>
<li><strong>多个回调函数</strong></li>
</ul>
<p>就像JavaScript中函数可以传入多个参数一样，函数可以调用多个回调函数。下面给一个jQuery中的ajax例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">successCallback</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Do stuff before send​</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">​<span class="function"><span class="keyword">function</span> <span class="title">successCallback</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Do stuff if success message received​</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">​<span class="function"><span class="keyword">function</span> <span class="title">completeCallback</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Do stuff upon completion​</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">​<span class="function"><span class="keyword">function</span> <span class="title">errorCallback</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Do stuff if error received​</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">  url: <span class="string">"http://fiddle.jshell.net/favicon.png"</span>,</div><div class="line">  success: successCallback,</div><div class="line">  complete: completeCallback,</div><div class="line">  error: errorCallback</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><strong>“Call Hell”问题和解决方法</strong></li>
</ul>
<p>相信每一个JS程序员都曾被或者正在被回调地狱所折磨，特别是写过Nodejs代码的程序员。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">asyncFun1(<span class="function"><span class="keyword">function</span>(<span class="params">err, a</span>) </span>&#123;</div><div class="line">    <span class="comment">// do something with a in function 1</span></div><div class="line">    asyncFun2(<span class="function"><span class="keyword">function</span>(<span class="params">err, b</span>) </span>&#123;</div><div class="line">      <span class="comment">// do something with b in function 2</span></div><div class="line">      asyncFun3(<span class="function"><span class="keyword">function</span>(<span class="params">err, c</span>) </span>&#123;</div><div class="line">          <span class="comment">// do something with c in function 3</span></div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>JS的后续传递风格（回调）是这门语言的优点也是这门语言的缺点，优点之一是我们可以很轻易的写出异步执行的代码，而缺点也是由异步引起的，当太多的异步步骤需要一步一步执行，或者一个函数里有太多的异步操作，这时候就会产生大量嵌套的回调，使代码嵌套太深而难以阅读和维护，即所谓的回调地狱。</p>
<p>最基本的解决此问题的两种思路一是使用具名函数，并保持代码层级不要太深。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params">err, c</span>) </span>&#123;</div><div class="line">    <span class="comment">// do something with a in function 3</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">err, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// do something with b in function 2 </span></div><div class="line">    asyncFun3(fun3);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">err, a</span>) </span>&#123;</div><div class="line">    <span class="comment">// do something with a in function 1</span></div><div class="line">    asyncFun2(fun2);</div><div class="line">&#125;</div><div class="line">asyncFun1(fun1);</div></pre></td></tr></table></figure>
<p>二是做好模块划分，保持模块功能独立性。<br>进阶一些的做法有ES6推行的Promise和Generator、async等辅助库等，这个以后再介绍吧。</p>
<h3 id="4-实际用例"><a href="#4-实际用例" class="headerlink" title="4. 实际用例"></a>4. 实际用例</h3><ul>
<li><p>资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。</p>
</li>
<li><p>DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。</p>
</li>
<li><p>setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现。</p>
</li>
<li><p>链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现。</p>
</li>
<li><p>setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回调函数主要体现在函数式编程的编程方式，即使用函数作为参数。函数式编程在编程的进阶领域会有充分的体现，需要进行一段时间的学习和练习。&lt;br&gt;所幸函数式编程在很多语言规范里都有明确的定义和解释，而函数式编程中主要用到的方法就是回调函数。回调函数的在进阶的JavaScript中常有用到，但其实有一些理解之后，用法和传入普通参数并无太大差异。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlewin.info/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Learning - apply，call和bind浅析</title>
    <link href="http://littlewin.info/2015/11/29/JavaScript%20Learning%20-%20apply%EF%BC%8Ccall%E5%92%8Cbind%E6%B5%85%E6%9E%90/"/>
    <id>http://littlewin.info/2015/11/29/JavaScript Learning - apply，call和bind浅析/</id>
    <published>2015-11-29T09:06:33.000Z</published>
    <updated>2016-09-29T09:11:26.425Z</updated>
    
    <content type="html"><![CDATA[<p>对于Javascript开发者而言，<code>apply</code>，<code>call</code>和<code>bind</code>这三个方法极其重要，因此需要对其形成更深刻的理解。而现实中感觉这三个方法的使用深度较浅，在此稍作深入学习加以记录吧。<br><a id="more"></a> </p>
<h3 id="1-共性"><a href="#1-共性" class="headerlink" title="1. 共性"></a>1. 共性</h3><p><code>apply</code>，<code>call</code>和<code>bind</code>方法的共同点是它们的第一个参数都是想将方法赋予给的对象。</p>
<h3 id="2-apply和call"><a href="#2-apply和call" class="headerlink" title="2. apply和call"></a>2. apply和call</h3><p><code>apply</code>和<code>call</code>将方法绑定到具体的对象并执行，它们的区别在于第二个参数 - <code>call</code>需要把参数按顺序传递进去，而<code>apply</code>则是把参数放在数组里。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func.call(<span class="keyword">this</span>, arg1, arg2);</div><div class="line">func.apply(<span class="keyword">this</span>, [arg1, arg2])</div></pre></td></tr></table></figure></p>
<h4 id="2-1-绑定对象"><a href="#2-1-绑定对象" class="headerlink" title="2.1 绑定对象"></a>2.1 绑定对象</h4><p>先来一个简单的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量​</span></div><div class="line"><span class="keyword">var</span> avgScore = <span class="string">"global avgScore"</span>;</div><div class="line"><span class="comment">// 全局函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">avg</span> (<span class="params">arrayOfScores</span>) </span>&#123;</div><div class="line">  <span class="comment">// 统计score值得总和</span></div><div class="line">  <span class="keyword">var</span> sumOfScores = arrayOfScores.reduce (<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + cur;</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// 这里this会绑定到全局对象，除非使用apply或call</span></div><div class="line">  <span class="keyword">this</span>.avgScore = sumOfScores / arrayOfScores.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gameController = &#123;</div><div class="line">  scores :[<span class="number">20</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">77</span>],</div><div class="line">  avgScore:<span class="literal">null</span>​</div><div class="line">&#125;</div><div class="line"></div><div class="line">avg (gameController.scores);</div><div class="line"><span class="built_in">console</span>.log (<span class="built_in">window</span>.avgScore); <span class="comment">// 46.4​</span></div><div class="line"><span class="built_in">console</span>.log (gameController.avgScore); <span class="comment">// null​</span></div><div class="line"></div><div class="line"><span class="comment">// 重置全局变量​</span></div><div class="line">avgScore = <span class="string">"global avgScore"</span>;</div><div class="line"><span class="comment">// 使用call绑定对象gameController</span></div><div class="line">avg.call (gameController, gameController.scores);</div><div class="line"><span class="built_in">console</span>.log (<span class="built_in">window</span>.avgScore); <span class="comment">//global avgScore</span></div><div class="line"><span class="built_in">console</span>.log (gameController.avgScore); <span class="comment">// 46.4​</span></div></pre></td></tr></table></figure></p>
<p>再来看一个回调函数的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> clientData = &#123;</div><div class="line">  id: <span class="number">094545</span>,</div><div class="line">  fullName: <span class="string">"Not Set"</span>,</div><div class="line">  setUserName: <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.fullName = firstName + <span class="string">" "</span> + lastName;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInput</span> (<span class="params">firstName, lastName, callback, callbackObj</span>) </span>&#123;</div><div class="line">  callback.apply (callbackObj, [firstName, lastName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>apply</code>将方法绑定给<code>callbackObj</code>对象，不会去影响全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getUserInput (<span class="string">"Barack"</span>, <span class="string">"Obama"</span>, clientData.setUserName, clientData);</div><div class="line"><span class="built_in">console</span>.log (clientData.fullName); <span class="comment">// Barack Obama​</span></div></pre></td></tr></table></figure></p>
<p><code>this</code>对象在Javascript代码中意义重大，<code>apply</code>和<code>call</code>可以方便的让我们改变函数执行的<code>this</code>环境。在JavaScript代码实现中，这两者将会经常被用到。</p>
<h4 id="2-2-借用函数"><a href="#2-2-借用函数" class="headerlink" title="2.2 借用函数"></a>2.2 借用函数</h4><p><code>apply</code>和<code>call</code>一般被用来借用函数，常见的用法如下，</p>
<ul>
<li>借用Array数组方法</li>
</ul>
<p>JavaScript编程中经常会遇到一些伪数组（类似数组的对象，不含负键值），这些伪数组往往需要调用很多原生的数组方法，此时往往可以利用<code>Array.prototype</code>中的原型方法加<code>apply</code>、<code>call</code>方法来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 伪数组对象</span></div><div class="line"><span class="keyword">var</span> anArrayLikeObj = &#123;<span class="number">0</span>:<span class="string">"Martin"</span>, <span class="number">1</span>:<span class="number">78</span>, <span class="number">2</span>:<span class="number">67</span>, <span class="number">3</span>:[<span class="string">"Letta"</span>, <span class="string">"Marieta"</span>, <span class="string">"Pauline"</span>], length:<span class="number">4</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// slice</span></div><div class="line"><span class="keyword">var</span> newArray = <span class="built_in">Array</span>.prototype.slice.call (anArrayLikeObj, <span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log (newArray); <span class="comment">// ["Martin", 78, 67, Array[3]]​</span></div><div class="line"></div><div class="line"><span class="comment">// indexOf</span></div><div class="line"><span class="built_in">console</span>.log (anArrayLikeObj.indexOf (<span class="string">"Martin"</span>) === <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>); <span class="comment">// Error: Object has no method 'indexOf</span></div><div class="line"><span class="built_in">console</span>.log (<span class="built_in">Array</span>.prototype.indexOf.call (anArrayLikeObj, <span class="string">"Martin"</span>) === <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// Reverse</span></div><div class="line"><span class="built_in">console</span>.log (<span class="built_in">Array</span>.prototype.reverse.call (anArrayLikeObj)); <span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, 3: "Martin", length: 4&#125;​</span></div><div class="line"></div><div class="line"><span class="comment">// Pop​</span></div><div class="line"><span class="built_in">console</span>.log (<span class="built_in">Array</span>.prototype.pop.call (anArrayLikeObj));</div><div class="line"><span class="built_in">console</span>.log (anArrayLikeObj); <span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, length: 3&#125;​</span></div><div class="line"></div><div class="line"><span class="comment">// Push</span></div><div class="line"><span class="built_in">console</span>.log (<span class="built_in">Array</span>.prototype.push.call (anArrayLikeObj, <span class="string">"Jackie"</span>));</div><div class="line"><span class="built_in">console</span>.log (anArrayLikeObj); <span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, 3: "Jackie", length: 4&#125;​</span></div></pre></td></tr></table></figure>
<p><code>arguments</code>是JavaScript中函数的属性，用来表示参数，这就是一个伪数组，通常我们利用<code>apply</code>和<code>call</code>方法调用数组方法检验每一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">transitionTo</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call (<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  <span class="built_in">console</span>.log (args);</div><div class="line">&#125;</div><div class="line"></div><div class="line">transitionTo (<span class="string">"contact"</span>, <span class="string">"Today"</span>, <span class="string">"20"</span>); <span class="comment">// ["Today", "20"]​</span></div></pre></td></tr></table></figure>
<ul>
<li>借用String对象方法</li>
</ul>
<p>String对象一般不可变，所以一些固定的数组可以借用String对象方法。</p>
<ul>
<li>借用其他自定义方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gameController = &#123;</div><div class="line">  scores: [<span class="number">20</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">77</span>],</div><div class="line">  avgScore: <span class="literal">null</span>,</div><div class="line">  players: [</div><div class="line">    &#123;name:<span class="string">"Tommy"</span>, playerID:<span class="number">987</span>, age:<span class="number">23</span>&#125;</div><div class="line">    &#123;name:<span class="string">"Pau"</span>, playerID:<span class="number">87</span>, age:<span class="number">33</span>&#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> appController = &#123;</div><div class="line">  scores: [<span class="number">900</span>, <span class="number">845</span>, <span class="number">809</span>, <span class="number">950</span>],</div><div class="line">  avgScore: <span class="literal">null</span>,</div><div class="line">  avg: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sumOfScores = <span class="keyword">this</span>.scores.reduce (<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> prev + cur;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.avgScore = sumOfScores / <span class="keyword">this</span>.scores.length;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">appController.avg.apply(gameController);</div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// 46.4​</span></div><div class="line"><span class="built_in">console</span>.log(appController.avgScore);  <span class="comment">// null​</span></div></pre></td></tr></table></figure>
<h3 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind"></a>3. bind</h3><blockquote>
<p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<p>bind方法和apply、call方法很类似，也可以改变函数体内this的指向。在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    bar : <span class="number">1</span>,</div><div class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">      $(<span class="string">'.someClass'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="comment">/* Act on the event */</span></div><div class="line">        <span class="built_in">console</span>.log(_this.bar);    <span class="comment">//1</span></div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    bar : <span class="number">1</span>,</div><div class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      $(<span class="string">'.someClass'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="comment">/* Act on the event */</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar);    <span class="comment">//1</span></div><div class="line">      &#125;.bind(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上述代码里，bind创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文this(其实就是 foo)，到bind函数中。然后，当回调函数被执行的时候， this便指向foo对象。</p>
<p>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    x:<span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sed = &#123;</div><div class="line">    x:<span class="number">4</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed);</div><div class="line">func();    <span class="comment">//?</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> fiv = &#123;</div><div class="line">    x:<span class="number">5</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</div><div class="line">func();    <span class="comment">//?</span></div></pre></td></tr></table></figure>
<p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind的实现，相当于使用函数在内部包了一个call / apply，第二次 bind() 相当于再包住第一次bind，故第二次以后的 bind 是无法生效的。</p>
<h3 id="4-区别"><a href="#4-区别" class="headerlink" title="4.区别"></a>4.区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    x: <span class="number">81</span>,</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)());    <span class="comment">//Note the () after bind</span></div><div class="line"><span class="built_in">console</span>.log(foo.getX.call(obj));</div><div class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj));</div></pre></td></tr></table></figure>
<p>当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用bind() 方法；而 apply/call 则会立即执行函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于Javascript开发者而言，&lt;code&gt;apply&lt;/code&gt;，&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;bind&lt;/code&gt;这三个方法极其重要，因此需要对其形成更深刻的理解。而现实中感觉这三个方法的使用深度较浅，在此稍作深入学习加以记录吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlewin.info/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTML进阶-优化设计</title>
    <link href="http://littlewin.info/2015/09/24/HTML%E8%BF%9B%E9%98%B6-%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/"/>
    <id>http://littlewin.info/2015/09/24/HTML进阶-优化设计/</id>
    <published>2015-09-24T15:26:42.000Z</published>
    <updated>2016-09-27T03:45:03.614Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>时至今日，网页加载的性能已经很大程度影响了网页的体验效果。而提到加载性能的提升点，大部分人会想到<code>图片优化</code>、<code>JavaScript优化</code>、<code>服务器配置升级</code>、<code>文件压缩</code>甚至是<code>CSS压缩</code>这些方式。反而在前端初学阶段接触的HTML代码的质量，容易被忽视。<br>网页内容的丰富离不开页面元素的快速累积，举一个典型值，YouTube的首页元素大概有3500个。网页性能的提升无法靠精简元素来实现，特别是HTML5还在多媒体方面增加了更多的标签。但是如果在页面开发之初，就注重HTML代码的清晰，干净，整洁，对提升网页性能十分有益。在初学阶段，就培养良好的开发习惯，不仅能够让你的网页在许多设备上都能快速正常的加载运行，而且会另你的项目易于debug和维护。</p>
<blockquote>
<p>HTML用于搭建架构，至少要保证脱离CSS和JavaScript之后页面可基本呈现。<br>CSS用于美化样式，尽可能在完成需求的前提下精简。<br>JavaScript用于控制行为，完成上述二者无法完成的附加功能</p>
</blockquote>
<a id="more"></a> 
<h5 id="一、结构至上"><a href="#一、结构至上" class="headerlink" title="一、结构至上"></a>一、结构至上</h5><p>网页的总体设计原则是 － “渐进增强，优雅降级”，而HTML作为这一切的基石，在搭建之初就应该最先被考虑，总体而言，在初学阶段，需要注意以下几点：</p>
<h5 id="页面结构的完整性"><a href="#页面结构的完整性" class="headerlink" title="页面结构的完整性"></a>页面结构的完整性</h5><p>完整HTML包括“DOCTYPE声明”，“head网页信息” “body网页具体内容”。采用HTML5标准时开头应该加上&lt;!DOCTYPE html&gt;，在<code>&lt;head&gt;</code>标签中引入资源文件，像这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"/styles/global.css"</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        ...</div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h6 id="标签结构的完备性"><a href="#标签结构的完备性" class="headerlink" title="标签结构的完备性"></a>标签结构的完备性</h6><ol>
<li>要准备好备用内容：比如给<code>&lt;track&gt;</code>元素添加说明和副标题，给<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>元素添加备用的文字或者图片，视频内容配上相应的截图或海报，每张图片都要加<code>alt</code>属性（如果图片只是用来装饰页面的话可以给<code>alt</code>赋空值）。</li>
<li>链接要加<code>title</code>属性，<code>title</code>必须要有意义，不要只是链接的复述。</li>
</ol>
<h6 id="结构顺序和视觉顺序基本保持一致"><a href="#结构顺序和视觉顺序基本保持一致" class="headerlink" title="结构顺序和视觉顺序基本保持一致"></a>结构顺序和视觉顺序基本保持一致</h6><ol>
<li>按照从上至下、从左到右的视觉顺序书写HTML结构。</li>
<li>有时候为了便于搜索引擎抓取，可将重要内容在HTML结构顺序上提前。</li>
<li>用<code>div</code>代替<code>table</code>布局，可以使HTML更具灵活性，也方便利用CSS控制。</li>
<li><code>table</code>不建议用于布局，但表现具有明显表格形式的数据，<code>table</code>还是首选。</li>
</ol>
<h6 id="保持良好简洁的树形结构"><a href="#保持良好简洁的树形结构" class="headerlink" title="保持良好简洁的树形结构"></a>保持良好简洁的树形结构</h6><ol>
<li>每一个块级元素都另起一行，每一行都使用Tab缩进对齐（<code>head</code>和<code>body</code>的子元素不需要缩进），删除冗余的行尾的空格。</li>
<li>使用2个空格代替1个Tab（大多数编辑器中可设置）。</li>
<li>对于内容较为简单的元素，建议将其写成单行。</li>
<li>大的模块之间用空行隔开，使模块更清晰。</li>
</ol>
<h5 id="二、语义化设计"><a href="#二、语义化设计" class="headerlink" title="二、语义化设计"></a>二、语义化设计</h5><p>语义化的意思是从名称一眼就能看出其内容和作用是什么，HTML的标签就是通过使用浅显易懂的元素名和属性名来实现语义化。HTML5引进了一些新的语义化元素，比如<code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>和<code>&lt;nav&gt;</code>。一定要针对内容使用相应的语义化元素，便于理解代码：</p>
<ol>
<li>标题使用<code>&lt;h1&gt;</code>(<code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>…)，列表使用<code>&lt;ul&gt;</code>或者<code>&lt;ol&gt;</code>。</li>
<li><code>&lt;article&gt;</code>内容中的标题应该从<code>&lt;h1&gt;</code>开始。</li>
<li>在适当的地方使用HTML5的新元素，比如   <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>,  <code>&lt;nav&gt;</code>和<code>&lt;aside&gt;</code>。</li>
<li>正文中的文本内容要用 <code>&lt;p&gt;</code>标签，内容的结构化可以使用HTML5的新元素（或者<code>&lt;div&gt;</code>），不要颠倒。</li>
<li>修改文字样式时，<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>要比<code>&lt;i&gt;</code>和<code>&lt;b&gt;</code>更好些，因为前者语义更加明显。</li>
<li><code>&lt;form&gt;</code>中要包含<code>&lt;label&gt;</code>元素，<code>&lt;input&gt;</code>元素要有 <code>type</code>、<code>placeholder</code>以及其他必要的属性，即使值为空都可以。</li>
<li>不要把文字和元素混合在一起，采用完全元素化布局，比如这样：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </div><div class="line">    Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  写成这样会更好</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="三、布局"><a href="#三、布局" class="headerlink" title="三、布局"></a>三、布局</h5><p>样式一定是由CSS控制的，但HTML的设计中也要考虑到一些便于布局的事项：</p>
<ol>
<li><code>&lt;p&gt;</code>元素用来放文字，而不是用来布局，在浏览器自身的样式表中默认<code>&lt;p&gt;</code>有margin和其他样式。</li>
<li>想实现换行可以使用<code>&lt;block&gt;</code>元素或者CSS的<code>display</code>属性，尽量避免使用<code>&lt;br&gt;</code>来换行。文字内容中的换行可以用<code>&lt;br&gt;</code>，但通常也很少这样用，有时在诗文中会把<code>&lt;br&gt;</code>作为标点来使用。</li>
<li>避免使用<code>&lt;hr&gt;</code>，因为这个元素对语义和结构都没有太大帮助，反而<code>&lt;hr&gt;</code>极差的灵活性对布局和显示都有很大的影响。</li>
<li>不要滥用<code>&lt;div&gt;</code>，W3C对<code>&lt;div&gt;</code>的描述是这样的：当没有其他元素可用时才能使用<code>&lt;div&gt;</code>。如果想让<code>&lt;link&gt;</code>和<code>&lt;img&gt;</code>这类元素能够在结尾换行，可以在样式中添加<code>display: block</code>，这样要比把它们放进<code>&lt;div&gt;</code>或者使用<code>&lt;br&gt;</code>来换行要好得多。</li>
<li>必须知道哪些是块级元素，这样就可以避免把块级元素放到<code>&lt;div&gt;</code>里面，比如列表就不需要放到<code>&lt;div&gt;</code>里面。</li>
<li><code>&lt;table&gt;</code>是用来放表格数据的，不是用来布局的。</li>
</ol>
<h5 id="四、Web三大件的配合"><a href="#四、Web三大件的配合" class="headerlink" title="四、Web三大件的配合"></a>四、Web三大件的配合</h5><h6 id="开发顺序"><a href="#开发顺序" class="headerlink" title="开发顺序"></a>开发顺序</h6><ol>
<li>首先完成HTML的设计，具体的设计准则在之前三点都有所提及。</li>
<li>然后根据样式需求来设计CSS，会在后续学习记录里更新。</li>
<li>最后在确实需要的情况下才设计JavaScript，会在后续学习记录里更新。</li>
</ol>
<h6 id="文件配合"><a href="#文件配合" class="headerlink" title="文件配合"></a>文件配合</h6><ol>
<li>保持结构、样式、行为的独立性。<br> 将CSS和JavaScript文件进行归档，与HTML文件分开（这样不仅有助于页面缓存，而且可以使后期Debug更容易），这之后再把CSS和JavaScript链接到HTML中，可以根据需要来对CSS和JavaScript代码进行压缩加密。</li>
<li><p>按需加载：<br> 应在head标签中引入CSS文件，这样浏览器就可以在输出HTML之前获取CSS信息：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"/styles/global.css"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 在 <code>&lt;body&gt;</code>标签的末尾引入JavaScript文件，这样可以在页面显示之后再编译JavaScript文件，以加快页面读取速度，同时有助于JavaScript对页面中的元素进行操作，像这样：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </div><div class="line">    ... </div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/index.js"</span>&gt;</span><span class="xml"></span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>避免内联样式或内联操作<br> 例如：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">"background-color:red;"</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"handleFoo()"</span>&gt;</span>Foo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 这些内联操作会在web项目复杂度提升后给后期扩展和维护带来很多风险，应避免使用。</p>
</li>
</ol>
<h5 id="五、其它、"><a href="#五、其它、" class="headerlink" title="五、其它、"></a>五、其它、</h5><p>本文主要给予前端初学者在设计之初的一些借鉴之处，在页面设计的后期工作中，测试特别是对不同屏幕和使用环境的适配也是值得注重的问题，这部分内容会在引入调试和打包工具的介绍之后再进行探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h5&gt;&lt;p&gt;时至今日，网页加载的性能已经很大程度影响了网页的体验效果。而提到加载性能的提升点，大部分人会想到&lt;code&gt;图片优化&lt;/code&gt;、&lt;code&gt;JavaScript优化&lt;/code&gt;、&lt;code&gt;服务器配置升级&lt;/code&gt;、&lt;code&gt;文件压缩&lt;/code&gt;甚至是&lt;code&gt;CSS压缩&lt;/code&gt;这些方式。反而在前端初学阶段接触的HTML代码的质量，容易被忽视。&lt;br&gt;网页内容的丰富离不开页面元素的快速累积，举一个典型值，YouTube的首页元素大概有3500个。网页性能的提升无法靠精简元素来实现，特别是HTML5还在多媒体方面增加了更多的标签。但是如果在页面开发之初，就注重HTML代码的清晰，干净，整洁，对提升网页性能十分有益。在初学阶段，就培养良好的开发习惯，不仅能够让你的网页在许多设备上都能快速正常的加载运行，而且会另你的项目易于debug和维护。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML用于搭建架构，至少要保证脱离CSS和JavaScript之后页面可基本呈现。&lt;br&gt;CSS用于美化样式，尽可能在完成需求的前提下精简。&lt;br&gt;JavaScript用于控制行为，完成上述二者无法完成的附加功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://littlewin.info/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://littlewin.info/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Hello, new transform</title>
    <link href="http://littlewin.info/2015/09/08/Hello-new-transform/"/>
    <id>http://littlewin.info/2015/09/08/Hello-new-transform/</id>
    <published>2015-09-08T14:51:36.000Z</published>
    <updated>2016-09-06T11:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>来到深圳参加工作已经快到俩月，工作和生活基本进入了一个新的稳态，这个阶段最应该放下之前的波折，重新审视内心，制定计划。</p>
<a id="more"></a> 
<p><em>ABOUT WORK</em><br>以前基本是在写嵌入式硬件上的驱动和系统应用代码，实习过程也是在从事持续集成系统后台的脚本的开发，前端的东西在持续的了解，但从未深入学习过。前端涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把各个终端界面更好地呈现给用户。于我而言，这是一件很屌的事情，于是，我要转型，并且开启了这个<a href="http://littlewin.info" title="Littlewin&#39;s blog">blog</a>来记录这个过程的点滴。</p>
<p><em>ABOUT LIFE</em><br>－ 刚参加工作就想着转型的确是一件很荒唐的事情，我愿意为此付出很多时间的经济上的支出，有目标驱动，有挤出来的资源支持，最终还希望有能力去重新选择。<br>－ 执行力在某些方面的体现已经不错了，其他方面仍需补齐，这最终将一一被时间和记录所检验。<br>－ 在很远的地方打通一处心扉是件不太容易的事情，我是一个结果导向的人，希望一点一滴的煎熬和坚持最终能换来终点的释怀。</p>
<p>其实汇总之后就是一句话，不服就干！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来到深圳参加工作已经快到俩月，工作和生活基本进入了一个新的稳态，这个阶段最应该放下之前的波折，重新审视内心，制定计划。&lt;/p&gt;
    
    </summary>
    
    
      <category term="感言" scheme="http://littlewin.info/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="工作" scheme="http://littlewin.info/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
</feed>
