<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> WEB跨域的实现 | Littlewin's blog</title><meta name="description" content="WEB跨域的实现 - Littlewin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/casual.css"><link rel="stylesheet" href="/css/semantic.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://littlewin.info/atom.xml" title="Littlewin's blog"></head><body><div class="sidebar"><div class="ui vertical inverted menu"><div class="h100"></div><h3 class="ui inverted aligned icon header"><div class="content"><a href="/" class="title-link">LITTLEWIN'S BLOG</a></div></h3><div class="h50"></div><div class="side-nav"><a href="/" target="_self" class="item">HOME<i class="icon home"></i></a><a href="/archives" target="_self" class="item">ARCHIVE<i class="icon archive"></i></a><a href="/tags" target="_self" class="item">TAGS<i class="icon tags"></i></a><a href="/about" target="_self" class="item">INFO<i class="icon info"></i></a><a href="/atom.xml" target="_self" class="item">RSS<i class="icon rss"></i></a></div><div class="item"><div class="ui inverted transparent icon input"><input type="text" placeholder="Search..." class="st-default-search-input"><i class="search icon"></i></div></div><div class="h50"></div></div><div class="h50 mq"><a class="ui teal big label"><i class="content icon"></i></a></div><div class="author-info"><a href="/" class="img-link"><img src="/avatar.png" class="author-photo ui tiny circular image"></a><h4 class="ui aligned icon header"><div class="content">Littlewin</div></h4><p class="author-desc">朝着前端打怪升级中 | 目前从事闪存产品的固件和测试工具开发工作 | 多特蒙德死忠</p><div class="social-outer"><div class="social-inner"><a href="http://github.com/littlewin-wang" target="_blank" class="social-link"><i class="icon github"></i></a><a href="http://twitter.com/littlewin_wang" target="_blank" class="social-link"><i class="icon twitter"></i></a><a href="http://weibo.com/fredinweibo" target="_blank" class="social-link"><i class="icon weibo"></i></a></div></div></div></div><div class="main"><div class="wrap"><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">WEB跨域的实现</h1><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jan 8, 2016</div></h6></div></div><div class="post-content"><p><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-10-10/47252019.jpg" width="60%" height="60%"></p>
<p>在开发现代WEB应用时，常常会遇到以下情形：</p>
<ol>
<li>客户端使用JavaScript</li>
<li>需要跨域加载服务</li>
<li>如果采用常规的XMLHttpRequest方法，最终会在浏览器终端里显示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load [http://external.service/](http://external.service/).</div><div class="line">No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</div><div class="line">Origin &apos;[http://my.app](http://my.app/)&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
</li>
</ol>
<p>每当WEB应用需要跨域加载API时，往往会遇到这种错误，本文就以此问题入手，记录下WEB跨域的学习笔记。</p>
<a id="more"></a>
<h3 id="同源策略（Same-origin-policy）"><a href="#同源策略（Same-origin-policy）" class="headerlink" title="同源策略（Same origin policy）"></a>同源策略（Same origin policy）</h3><p>同源策略（SOP）是一种WEB安全约定，它的主要目的是抑制来自不同域的文件的相互影响。</p>
<p>一个页面的源由<strong>协议</strong>、<strong>域名</strong>、<strong>端口号</strong>决定，举例，本博客的源地址是（’http’, ‘littlewin.info’, 80）。同源之间的资源文件可以互相访问。如果页面A和页面B拥有相同的源，A页面上的JavaScript代码可以使用HTTP请求访问B的资源，操作B的DOM结构，甚至设置B的cookies。需要注意的是，源是由页面的地址定义的，一个通过CDN引用的JavaScript文件是运行在包含此文件的HTML页面上，而非它的引用地址上。</p>
<p>对于特定的跨域HTTP请求，SOP规定以下一般规则：允许跨域写，禁止跨域读取。这意味着如果A和C是不同的源，A发送的HTTP请求会由C正确地接收（这些就是“写”），但是A中的脚本将无法读取任何数据–甚至来自C返回的响应代码。跨域“读取”会被浏览器屏蔽，导致出现上面的错误。换句话说，<strong>SOP不阻止攻击者向他们源写数据，它只是不允许他们读取来自你的域的数据（cookie, localStorage 或其他）或利用接收到的响应来做任何事。</strong></p>
<p>SOP策略是是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。</p>
<h3 id="执行跨域请求"><a href="#执行跨域请求" class="headerlink" title="执行跨域请求"></a>执行跨域请求</h3><p>然而，有时你必须执行跨域请求，而这需要一些额外的操作。合法的跨域请求示例：</p>
<ul>
<li>你必须集成第三方服务（如一个论坛），有一个REST API驻留在不同源。</li>
<li>服务器端服务托管在不同的（子）域。</li>
<li>客户端逻辑来自不同源而不是服务器端服务端点。</li>
<li>…</li>
</ul>
<p>根据应用的跨服务器规模，可以采用多个选项来启用跨域请求。本文将讨论可能的解决方案：JSONP, 使用服务器端代理和CORS。</p>
<p>当然还有其他选择，使用较广泛的的技术是使用iframes和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a>，这些不在本文讨论。</p>
<h3 id="跨域请求示例"><a href="#跨域请求示例" class="headerlink" title="跨域请求示例"></a>跨域请求示例</h3><p>有2个网站，一个网站在源（‘http’,’localhost’,3000），另一个在（‘http’,’localhost’,3001）。它们是不同的源，所以3000请求3001被认为是跨域请求并被浏览器默认屏蔽。</p>
<p>考虑以下场景 - A域的页面想要执行一个GET请求到B域的页面：</p>
<p>浏览器向服务器端发送请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div></pre></td></tr></table></figure>
<p>服务器端返回响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line">Content-Length: 57</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the server&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而在接收到响应，浏览器屏蔽响应进一步传播，并显示跨域请求错误，如上所示。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JavaScript Object Notation with Padding（JSONP）是一种执行跨域请求的方法，通过利用HTML页面的script标签可以加载来自不同域的API。但这种方式有一些重大的问题：</p>
<ul>
<li>JSONP只能用来执行跨域GET请求。</li>
<li>服务器必须明确地支持JSONP请求。</li>
<li>你必须绝对地信任服务器提供的JSONP响应。</li>
<li>如果服务器被盗用，JSONP可以使你的网站暴露大量的<a href="http://security.stackexchange.com/questions/23438/security-risks-with-jsonp" target="_blank" rel="external">安全漏洞</a>。</li>
</ul>
<p>JSONP实现原理是 - <code>&lt;script&gt;</code>标签可以有来自不同域的资源，当浏览器解析<code>&lt;script&gt;</code>标签，它会GET请求脚本内容（来自任何源）并在当前的页面中执行。通常，服务器会返回HTML或一些XML或JSON数据。有时向一个启用JSONP的服务器请求时，它会返回一个脚本块，这个脚本块执行一个在页面中定义好的回调函数，并提供参数。以下举例：</p>
<p>源3000的页面想要获取存储在源3001的资源。源3000页面包含下面的script标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">'http://localhost:3001?callback=myCallbackFunction'</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>当浏览器解析这个script标签，它将正常的发出GET请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /?callback=myCallbackFunction HTTP/1.1</div></pre></td></tr></table></figure>
<p>服务器没法返回原生JSON，而是返回一个脚本块，包含函数的调用，函数名在URL中指定，输出的数据作为参数传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/javascript</div><div class="line"></div><div class="line">myCallbackFunction(&#123;&apos;response&apos;: &apos;hello world from JSONP!&apos;&#125;);</div></pre></td></tr></table></figure>
<p>这个脚本块在浏览器接收到后就立即被执行，当前页面定义了回调函数，它使用返回的数据作为参数。</p>
<p>Tips：</p>
<ul>
<li>由于JSONP的工作原理是通过一个script标签加载GET请求，因此它只支持跨域的HTTP GET请求。如果你想使用其他的HTTP请求（像POST, PUT或DELETE），就不能使用JSONP方法。</li>
<li>这个方法要求你必须完全地信任服务器。这个服务器可能被盗用，并返回任意代码，将在你的页面中执行（访问你的网站cookies, localStorage等等）。</li>
</ul>
<h3 id="服务器端代理"><a href="#服务器端代理" class="headerlink" title="服务器端代理"></a>服务器端代理</h3><p>这种绕过同源策略执行而跨域请求的方法没有任何跨域操作，而是使用一个代理服务器在后端访问外部服务，并把结果返回给客户端。请求代码和代理服务器是在同一个域中，因此并不违反同源策略。</p>
<p>这种机制不需要改变现有的服务器代码，它需要服务器端采用代理服务，且在当前域中在浏览器中运行JavaScript代码。</p>
<p>这次不直接向3001域发送GET请求，而是向自己域的代理服务器发送请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /proxy?urlToFetch=http%3A%2F%2Flocalhost%3A3001 HTTP/1.1</div></pre></td></tr></table></figure></p>
<p>服务器将执行实际的GET请求外部服务。服务器端代码可以正常的执行跨域请求而不会发生错误，因此可以成功的调用。代理服务将结果输送给客户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the server, proxy style!&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这种方法也有一些严重的缺点。如果第三方服务使用cookies进行身份验证，那么你就不能使用这种方法。本地的JavaScript代码是不能访问外部的域的cookies并且也不能发送cookies给你的代理服务，所以包含用户验证信息的cookies无法提供给第三方服务。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>上述两种方法或多或少存在一些“hack”的感觉，实际上都是绕过浏览器的安全机制而实现。</p>
<p>HTML5引入了一个标准的跨域请求方法 -  <a href="http://www.w3.org/TR/cors/" target="_blank" rel="external">Cross-Origin Resource Sharing</a></p>
<p>CORS为服务器提供了一个准入机制，它告诉浏览器域A读取请求自域B的数据是可以的。这种方法是通过在http响应头中包含一个新的Access-Control-Allow-Origin属性值。当浏览器接收到跨域的响应时，它会检查CORS头。如果响应头中指定的源匹配当前源，它允许读取跨域访问的响应。否则，会得到上述错误信息。</p>
<p>像往常一样进行跨域请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div></pre></td></tr></table></figure>
<p>源3001的服务器检查是否这个源可以访问数据，并在响应中增加额外的Access-Control-Allow-Origin头，列出请求源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Access-Control-Allow-Origin: http://localhost:3000</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line">Content-Length: 62</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the CORS server&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当浏览器接收到响应时它比较请求源（3000）和列在Access-Control-Allow-Origin头的源（也是3000）。由于请求源出现在Access-Control-Allow-Origin值中，浏览器允许源3000的请求执行响应。</p>
<p>同样的，这种方法有一些局限性。例如老版本的IE只能<a href="http://caniuse.com/#search=CORS" target="_blank" rel="external">部分支持CORS</a>。 同时，对于非简单请求，在正式通信之前，增加了一次HTTP查询请求（参考：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a>）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比以上三种方法 - </p>
<p>JSONP只支持GET请求，服务器代理和CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。Proxy方式，通过强大的后端应用可以提供更灵活更能发挥想象力的服务。CORS是目前W3C支持的方式，在新浏览器上体验更好。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/18/乍暖还寒时候，最难将息/" class="prev"><button class="ui button teal">上一篇</button></a><a href="/2016/01/03/Objective-C学习之ARC/" class="next"><button class="ui button teal">下一篇</button></a></div><div data-thread-key="2016/01/08/WEB跨域的实现/" data-title="WEB跨域的实现" data-url="http://littlewin.info/2016/01/08/WEB跨域的实现/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"littlewin"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://littlewin.info">Littlewin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and theme by <a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">casual</a></p></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/jquery.scrollex.js"></script><script src="/js/semantic.min.js"></script><script src="/js/casual.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','TvAnFS4AVxjiJUvrZJRB','2.0.0');</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></div></body></html>