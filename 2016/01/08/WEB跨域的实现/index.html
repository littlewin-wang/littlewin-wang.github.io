<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> WEB跨域的实现 | Littlewin's blog</title><meta name="description" content="WEB跨域的实现 - Littlewin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="http://littlewin.info/atom.xml" title="Littlewin's blog"></head><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">主页</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">归档</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">关于</a></div><div class="nav-item"><a href="/atom.xml" target="_self" data-text="rss">订阅</a></div><div class="nav-item"><a href="/resume" target="_self" data-text="resume">求职</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">WEB跨域的实现</h1><span class="post-date">2016年1月8日</span><span class="post-tag"><a href="/tags/前端/">前端</a><a href="/tags/JavaScript/">JavaScript</a></span><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-10-10/47252019.jpg" class="bgimage"><div class="post-content"><p>在开发现代WEB应用时，常常会遇到以下情形：</p>
<ol>
<li>客户端使用JavaScript</li>
<li>需要跨域加载服务</li>
<li>如果采用常规的XMLHttpRequest方法，最终会在浏览器终端里显示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load [http://external.service/](http://external.service/).</div><div class="line">No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</div><div class="line">Origin &apos;[http://my.app](http://my.app/)&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
</li>
</ol>
<p>每当WEB应用需要跨域加载API时，往往会遇到这种错误，本文就以此问题入手，记录下WEB跨域的学习笔记。</p>
<a id="more"></a>
<h3 id="同源策略（Same-origin-policy）"><a href="#同源策略（Same-origin-policy）" class="headerlink" title="同源策略（Same origin policy）"></a>同源策略（Same origin policy）</h3><p>同源策略（SOP）是一种WEB安全约定，它的主要目的是抑制来自不同域的文件的相互影响。</p>
<p>一个页面的源由<strong>协议</strong>、<strong>域名</strong>、<strong>端口号</strong>决定，举例，本博客的源地址是（’http’, ‘littlewin.info’, 80）。同源之间的资源文件可以互相访问。如果页面A和页面B拥有相同的源，A页面上的JavaScript代码可以使用HTTP请求访问B的资源，操作B的DOM结构，甚至设置B的cookies。需要注意的是，源是由页面的地址定义的，一个通过CDN引用的JavaScript文件是运行在包含此文件的HTML页面上，而非它的引用地址上。</p>
<p>对于特定的跨域HTTP请求，SOP规定以下一般规则：允许跨域写，禁止跨域读取。这意味着如果A和C是不同的源，A发送的HTTP请求会由C正确地接收（这些就是“写”），但是A中的脚本将无法读取任何数据–甚至来自C返回的响应代码。跨域“读取”会被浏览器屏蔽，导致出现上面的错误。换句话说，<strong>SOP不阻止攻击者向他们源写数据，它只是不允许他们读取来自你的域的数据（cookie, localStorage 或其他）或利用接收到的响应来做任何事。</strong></p>
<p>SOP策略是是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。</p>
<h3 id="执行跨域请求"><a href="#执行跨域请求" class="headerlink" title="执行跨域请求"></a>执行跨域请求</h3><p>然而，有时你必须执行跨域请求，而这需要一些额外的操作。合法的跨域请求示例：</p>
<ul>
<li>你必须集成第三方服务（如一个论坛），有一个REST API驻留在不同源。</li>
<li>服务器端服务托管在不同的（子）域。</li>
<li>客户端逻辑来自不同源而不是服务器端服务端点。</li>
<li>…</li>
</ul>
<p>根据应用的跨服务器规模，可以采用多个选项来启用跨域请求。本文将讨论可能的解决方案：JSONP, 使用服务器端代理和CORS。</p>
<p>当然还有其他选择，使用较广泛的的技术是使用iframes和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a>，这些不在本文讨论。</p>
<h3 id="跨域请求示例"><a href="#跨域请求示例" class="headerlink" title="跨域请求示例"></a>跨域请求示例</h3><p>有2个网站，一个网站在源（‘http’,’localhost’,3000），另一个在（‘http’,’localhost’,3001）。它们是不同的源，所以3000请求3001被认为是跨域请求并被浏览器默认屏蔽。</p>
<p>考虑以下场景 - A域的页面想要执行一个GET请求到B域的页面：</p>
<p>浏览器向服务器端发送请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div></pre></td></tr></table></figure>
<p>服务器端返回响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line">Content-Length: 57</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the server&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而在接收到响应，浏览器屏蔽响应进一步传播，并显示跨域请求错误，如上所示。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JavaScript Object Notation with Padding（JSONP）是一种执行跨域请求的方法，通过利用HTML页面的script标签可以加载来自不同域的API。但这种方式有一些重大的问题：</p>
<ul>
<li>JSONP只能用来执行跨域GET请求。</li>
<li>服务器必须明确地支持JSONP请求。</li>
<li>你必须绝对地信任服务器提供的JSONP响应。</li>
<li>如果服务器被盗用，JSONP可以使你的网站暴露大量的<a href="http://security.stackexchange.com/questions/23438/security-risks-with-jsonp" target="_blank" rel="external">安全漏洞</a>。</li>
</ul>
<p>JSONP实现原理是 - <code>&lt;script&gt;</code>标签可以有来自不同域的资源，当浏览器解析<code>&lt;script&gt;</code>标签，它会GET请求脚本内容（来自任何源）并在当前的页面中执行。通常，服务器会返回HTML或一些XML或JSON数据。有时向一个启用JSONP的服务器请求时，它会返回一个脚本块，这个脚本块执行一个在页面中定义好的回调函数，并提供参数。以下举例：</p>
<p>源3000的页面想要获取存储在源3001的资源。源3000页面包含下面的script标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">'http://localhost:3001?callback=myCallbackFunction'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>当浏览器解析这个script标签，它将正常的发出GET请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /?callback=myCallbackFunction HTTP/1.1</div></pre></td></tr></table></figure>
<p>服务器没法返回原生JSON，而是返回一个脚本块，包含函数的调用，函数名在URL中指定，输出的数据作为参数传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/javascript</div><div class="line"></div><div class="line">myCallbackFunction(&#123;&apos;response&apos;: &apos;hello world from JSONP!&apos;&#125;);</div></pre></td></tr></table></figure>
<p>这个脚本块在浏览器接收到后就立即被执行，当前页面定义了回调函数，它使用返回的数据作为参数。</p>
<p>Tips：</p>
<ul>
<li>由于JSONP的工作原理是通过一个script标签加载GET请求，因此它只支持跨域的HTTP GET请求。如果你想使用其他的HTTP请求（像POST, PUT或DELETE），就不能使用JSONP方法。</li>
<li>这个方法要求你必须完全地信任服务器。这个服务器可能被盗用，并返回任意代码，将在你的页面中执行（访问你的网站cookies, localStorage等等）。</li>
</ul>
<h3 id="服务器端代理"><a href="#服务器端代理" class="headerlink" title="服务器端代理"></a>服务器端代理</h3><p>这种绕过同源策略执行而跨域请求的方法没有任何跨域操作，而是使用一个代理服务器在后端访问外部服务，并把结果返回给客户端。请求代码和代理服务器是在同一个域中，因此并不违反同源策略。</p>
<p>这种机制不需要改变现有的服务器代码，它需要服务器端采用代理服务，且在当前域中在浏览器中运行JavaScript代码。</p>
<p>这次不直接向3001域发送GET请求，而是向自己域的代理服务器发送请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /proxy?urlToFetch=http%3A%2F%2Flocalhost%3A3001 HTTP/1.1</div></pre></td></tr></table></figure></p>
<p>服务器将执行实际的GET请求外部服务。服务器端代码可以正常的执行跨域请求而不会发生错误，因此可以成功的调用。代理服务将结果输送给客户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the server, proxy style!&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这种方法也有一些严重的缺点。如果第三方服务使用cookies进行身份验证，那么你就不能使用这种方法。本地的JavaScript代码是不能访问外部的域的cookies并且也不能发送cookies给你的代理服务，所以包含用户验证信息的cookies无法提供给第三方服务。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>上述两种方法或多或少存在一些“hack”的感觉，实际上都是绕过浏览器的安全机制而实现。</p>
<p>HTML5引入了一个标准的跨域请求方法 -  <a href="http://www.w3.org/TR/cors/" target="_blank" rel="external">Cross-Origin Resource Sharing</a></p>
<p>CORS为服务器提供了一个准入机制，它告诉浏览器域A读取请求自域B的数据是可以的。这种方法是通过在http响应头中包含一个新的Access-Control-Allow-Origin属性值。当浏览器接收到跨域的响应时，它会检查CORS头。如果响应头中指定的源匹配当前源，它允许读取跨域访问的响应。否则，会得到上述错误信息。</p>
<p>像往常一样进行跨域请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div></pre></td></tr></table></figure>
<p>源3001的服务器检查是否这个源可以访问数据，并在响应中增加额外的Access-Control-Allow-Origin头，列出请求源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Access-Control-Allow-Origin: http://localhost:3000</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line">Content-Length: 62</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;response&quot;: &quot;This is data returned from the CORS server&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当浏览器接收到响应时它比较请求源（3000）和列在Access-Control-Allow-Origin头的源（也是3000）。由于请求源出现在Access-Control-Allow-Origin值中，浏览器允许源3000的请求执行响应。</p>
<p>同样的，这种方法有一些局限性。例如老版本的IE只能<a href="http://caniuse.com/#search=CORS" target="_blank" rel="external">部分支持CORS</a>。 同时，对于非简单请求，在正式通信之前，增加了一次HTTP查询请求（参考：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a>）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比以上三种方法 - </p>
<p>JSONP只支持GET请求，服务器代理和CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。Proxy方式，通过强大的后端应用可以提供更灵活更能发挥想象力的服务。CORS是目前W3C支持的方式，在新浏览器上体验更好。</p>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2016/01/20/JavaScript Learning - Promise入门/" class="prev">上一篇<span>JavaScript Learning - Promise入门</span></a></div><div class="post-next"><a href="/2016/01/03/Objective-C学习之ARC/" class="next">下一篇<span>Objective-C学习之ARC</span></a></div></div></div><div data-thread-key="2016/01/08/WEB跨域的实现/" data-title="WEB跨域的实现" data-url="http://littlewin.info/2016/01/08/WEB跨域的实现/" class="ds-share"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><span class="ds-more">分享到：</span></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul></div></div><div data-thread-key="2016/01/08/WEB跨域的实现/" data-title="WEB跨域的实现" data-url="http://littlewin.info/2016/01/08/WEB跨域的实现/" data-author-key="1" class="ds-thread"></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/littlewin-wang" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="http://twitter.com/littlewin_wang" target="_blank" class="link-twitter"><i class="icon icon-twitter"></i></a></li><li class="social-link"><a href="http://weibo.com/fredinweibo" target="_blank" class="link-weibo"><i class="icon icon-weibo"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> 近期文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/15/假如雨天也要唱歌的话/">假如雨天也要唱歌的话</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/30/2016年终总结/">2016年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/22/To be 27/">To be 27</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/09/再谈Littlewin/">再谈Littlewin</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/11月的Littlewin/">11月的Littlewin</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> 近期评论</h3><div class="widget-content"></div><ul class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-admin="1" data-excerpt-length="70" id="ds-recent-comments"></ul></div><div class="tag-lists widget"><h3 class="widget-title"> 标签</h3><div class="widget-content"><a class="tag-link" href="/tags/HTML/">HTML</a> <a class="tag-link" href="/tags/JavaScript/">JavaScript</a> <a class="tag-link" href="/tags/Objective-C/">Objective-C</a> <a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/前端/">前端</a> <a class="tag-link" href="/tags/工作/">工作</a> <a class="tag-link" href="/tags/感言/">感言</a> <a class="tag-link" href="/tags/生活/">生活</a></div></div><div class="archive-lists widget"><h3 class="widget-title"> 归档</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2017 <span class="icon icon-heart"></span> <a href="http://littlewin.info">Littlewin</a><span class="sep">/</span><a href="https://hexo.io/" target="_blank">Powered by Hexo</a><span class="sep">/</span><a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">Theme by casual</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/littlewin-wang" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="http://twitter.com/littlewin_wang" target="_blank" class="link-twitter"><i class="icon icon-twitter"></i></a></li><li class="social-link"><a href="http://weibo.com/fredinweibo" target="_blank" class="link-weibo"><i class="icon icon-weibo"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script>var duoshuoQuery = {short_name:"littlewin"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><!-- Place this tag in your head or just before your close body tag. --><script async defer src="https://buttons.github.io/buttons.js"></script></body></html>