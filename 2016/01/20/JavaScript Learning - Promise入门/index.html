<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript Learning - Promise入门 | Littlewin's blog</title><meta name="description" content="JavaScript Learning - Promise入门 - Littlewin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/casual.css"><link rel="stylesheet" href="/css/semantic.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://littlewin.info/atom.xml" title="Littlewin's blog"></head><body><div class="sidebar"><div class="ui vertical inverted menu"><div class="h100"></div><h3 class="ui inverted aligned icon header"><div class="content"><a href="/" class="title-link">LITTLEWIN'S BLOG</a></div></h3><div class="h50"></div><div class="side-nav"><a href="/" target="_self" class="item">HOME<i class="icon home"></i></a><a href="/archives" target="_self" class="item">ARCHIVE<i class="icon archive"></i></a><a href="/tags" target="_self" class="item">TAGS<i class="icon tags"></i></a><a href="/about" target="_self" class="item">INFO<i class="icon info"></i></a><a href="/atom.xml" target="_self" class="item">RSS<i class="icon rss"></i></a></div><div class="item"><div class="ui inverted transparent icon input"><input type="text" placeholder="Search..." class="st-default-search-input"><i class="search icon"></i></div></div><div class="h50"></div></div><div class="h50 mq"><a class="ui teal big label"><i class="content icon"></i></a></div><div class="author-info"><a href="/" class="img-link"><img src="/avatar.png" class="author-photo ui tiny circular image"></a><h4 class="ui aligned icon header"><div class="content">Littlewin</div></h4><p class="author-desc">朝着前端打怪升级中 | 目前从事闪存产品的固件和测试工具开发工作 | 多特蒙德死忠</p><div class="social-outer"><div class="social-inner"><a href="http://github.com/littlewin-wang" target="_blank" class="social-link"><i class="icon github"></i></a><a href="http://twitter.com/littlewin_wang" target="_blank" class="social-link"><i class="icon twitter"></i></a><a href="http://weibo.com/fredinweibo" target="_blank" class="social-link"><i class="icon weibo"></i></a></div></div></div></div><div class="main"><div class="wrap"><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript Learning - Promise入门</h1><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jan 20, 2016</div></h6></div></div><div class="post-content"><p>在很多需要与数据打交道的场合下，我们会遇到很多异步的情况,在异步操作的时候，我们还需要处理成功和失败两种情况，并且成功的时候，还可能需要把结果传递给下一个Ajax调用，从而形成”函数嵌套”的情况。callback是编写Javascript异步代码最最最简单的机制。可用这种原始的callback必须以牺牲控制流、异常处理和函数语义为代价。<br><a id="more"></a></p>
<h3 id="具体实现的库"><a href="#具体实现的库" class="headerlink" title="具体实现的库"></a>具体实现的库</h3><h4 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h4><p>只需要在浏览器中加载Polyfill类库，就能使用IE10等或者还没有提供对Promise支持的浏览器中使用Promise里规定的方法。</p>
<ul>
<li><a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="external">jakearchibald/es6-promise</a>：一个兼容 ES6 Promises 的Polyfill类库。它基于RSVP.js这个兼容Promises/A+ 的类库，它只是RSVP.js的一个子集，只实现了Promises 规定的API。</li>
<li><a href="https://github.com/yahoo/ypromise" target="_blank" rel="external">yahoo/ypromise</a>：这是一个独立版本的YUI的Promise Polyfill，具有和ES6 Promises的兼容性。</li>
<li><a href="https://github.com/getify/native-promise-only/" target="_blank" rel="external">getify/native-promise-only</a>：以作为ES6 Promises的polyfill为目的的类库，它严格按照ES6 Promises的规范设计，没有添加在规范中没有定义的功能。如果运行环境有原生的Promise支持的话，则优先使用原生的Promise支持。</li>
</ul>
<h4 id="扩展类库"><a href="#扩展类库" class="headerlink" title="扩展类库"></a>扩展类库</h4><p>Promise扩展类库除了实现了Promise中定义的规范之外，还增加了自己独自定义的功能。</p>
<ul>
<li><a href="https://github.com/then/promise" target="_blank" rel="external">then/promise</a>: a super set of ES6 Promises designed to have readable, performant code and to provide just the extensions that are absolutely necessary for using promises today.</li>
<li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">petkaantonov/bluebird</a>: 这个类库除了兼容 Promise 规范之外，还扩展了取消promise对象的运行，取得promise的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。</li>
<li><a href="https://github.com/cujojs/when" target="_blank" rel="external">when</a>: 大小很小,node和浏览器环境下都可以使用。</li>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">q</a>: 类库Q实现了Promises和Deferreds等规范。它自2009年开始开发，还提供了面向Node.js的文件IO API Q-IO等，是一个在很多场景下都能用得到的类库。</li>
</ul>
<h3 id="编写Promise代码"><a href="#编写Promise代码" class="headerlink" title="编写Promise代码"></a>编写Promise代码</h3><h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><ul>
<li>使用<code>new Promise(fn)</code>返回一个Promise对象</li>
<li>在在<code>fn</code>中制定异步等处理:<br>处理结果正常的情况，调用resolve(处理结果值)<br>处理结果错误的话,调用reject(Error对象)</li>
</ul>
<h4 id="创建Promise对象"><a href="#创建Promise对象" class="headerlink" title="创建Promise对象"></a>创建Promise对象</h4><p>最基本的情况，是使用<code>new Promise()</code>来创建Promise对象。也可以使用<code>Promise.resolve(value)</code>代替<code>new Promise()</code>快捷方法。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  reslove(<span class="number">42</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="Thenable"><a href="#Thenable" class="headerlink" title="Thenable"></a>Thenable</h4><p>就像我们有时称具有<code>.length</code>方法的非数组对象为Array like一样，thenable指的是一个具有<code>.then</code>方法的对象。</p>
<p>这种将thenable对象转换为promise对象的机制要求thenable对象所拥有的<code>then</code>方法应该和Promise所拥有的<code>then</code>方法具有同样的功能和处理过程，在将thenable对象转换为promise对象的时候，还会巧妙的利用thenable对象原来具有的<code>then</code>方法。变成了promise对象的话，就能直接使用<code>then</code>或者<code>catch</code>, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>));<span class="comment">// =&gt; promise对象</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的是:即使一个对象具有<code>.then</code>方法，也不一定就能作为ES6 Promises对象使用。比如jQuery的Defeered Object的then方法机制与Promise不同。</p>
<p>其实在Promise里可以将任意个方法连在一起作为一个方法链（method chain），比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="comment">// task A</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params">vaue</span>)</span>&#123;</div><div class="line">  <span class="comment">// task B</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><p><code>Promise.reject(error)</code>是和<code>Promise.resolve(value)</code>类似的静态方法，是<code>new Promise()</code>方法的快捷方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错了"</span>));</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错了"</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise的同步or异步调用"><a href="#Promise的同步or异步调用" class="headerlink" title="Promise的同步or异步调用"></a>Promise的同步or异步调用</h4><p>先看下面这段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReady</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> readyState = <span class="built_in">document</span>.readyState;</div><div class="line">  <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">    fn();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, fn);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">onReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>);</div></pre></td></tr></table></figure>
<p>这段代码会根据执行时DOM是否已经装载完毕来决定是对回调函数进行同步调用还是异步调用。这实际上会让我们的代码是同步还是一部产生混淆，所以为了解决这个问题，我们应该统一使用异步调用的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReady</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> readyState = <span class="built_in">document</span>.readyState;</div><div class="line">  <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">    setTimeout(fn, <span class="number">0</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, fn);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">onReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>);</div></pre></td></tr></table></figure>
<p>我们看到的<code>promise.then</code>也属于此类，为了避免上述中同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定Promise只能使用异步调用方式 ，修改代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReadyPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> readyState = <span class="built_in">document</span>.readyState;</div><div class="line">    <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">        resolve();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, resolve);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">onReadyPromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>);</div></pre></td></tr></table></figure>
<h4 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise#catch"></a>Promise#catch</h4><p>链式上的<code>catch</code>会捕获前面所有<code>then</code>的错误情况。其实这也是个语法糖:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"message"</span>));</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"message"</span>));</div><div class="line">promise.then(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>提倡使用<code>catch</code>的原因还有一个就是: 使用<code>promise.then(onFulfilled, onRejected)</code>的话, 在<code>onFulfilled</code>中发生异常的话，在<code>onRejected</code>中是捕获不到这个异常的。</p>
<p>然而实际上不管是<code>then</code>还是<code>catch</code>方法调用，都返回了一个新的promise对象。</p>
<h4 id="Promise-chain"><a href="#Promise-chain" class="headerlink" title="Promise chain"></a>Promise chain</h4><p>通过<code>then</code>方法，我们可以将代码写成方法链的形式。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Task A"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Task B"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Catch Error: A or B"</span>, error);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finalTask</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Final Task"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</div><div class="line">promise</div><div class="line">  .then(taskA)</div><div class="line">  .then(taskB)</div><div class="line">  .catch(onRejected)</div><div class="line">  .then(finalTask);</div></pre></td></tr></table></figure>
<p>chain的时候，如何传递参数？答案非常简单，那就是在 Task A 中 return 的返回值，会在 Task B 执行时传给它。因为return的值会由 Promise.resolve(return的返回值)进行相应的包装处理。</p>
<h3 id="多个Promise对象完成后统一处理"><a href="#多个Promise对象完成后统一处理" class="headerlink" title="多个Promise对象完成后统一处理"></a>多个Promise对象完成后统一处理</h3><h4 id="通过回调方式来进行多个异步调用"><a href="#通过回调方式来进行多个异步调用" class="headerlink" title="通过回调方式来进行多个异步调用"></a>通过回调方式来进行多个异步调用</h4><p>看代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURLCallback</span>(<span class="params">URL, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">  req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">      callback(<span class="literal">null</span>, req.responseText);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText), req.response);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    callback(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">  &#125;;</div><div class="line">  req.send();</div><div class="line">&#125;</div><div class="line"><span class="comment">// &lt;1&gt; 对JSON数据进行安全的解析</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonParse</span>(<span class="params">callback, error, value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (error) &#123;</div><div class="line">    callback(error, value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(value);</div><div class="line">      callback(<span class="literal">null</span>, result);</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      callback(e, value);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// &lt;2&gt; 发送XHR请求</span></div><div class="line"><span class="keyword">var</span> request = &#123;</div><div class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURLCallback(<span class="string">'http://azu.github.io/promises-book/json/comment.json'</span>, jsonParse.bind(<span class="literal">null</span>, callback));</div><div class="line">  &#125;,</div><div class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURLCallback(<span class="string">'http://azu.github.io/promises-book/json/people.json'</span>, jsonParse.bind(<span class="literal">null</span>, callback));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// &lt;3&gt; 启动多个XHR请求，当所有请求返回时调用callback</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">allRequest</span>(<span class="params">requests, callback, results</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (requests.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> callback(<span class="literal">null</span>, results);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> req = requests.shift();</div><div class="line">  req(<span class="function"><span class="keyword">function</span> (<span class="params">error, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">      callback(error, value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      results.push(value);</div><div class="line">      allRequest(requests, callback, results);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  allRequest([request.comment, request.people], callback, []);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 运行的例子</span></div><div class="line">main(<span class="function"><span class="keyword">function</span>(<span class="params">error, results</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(error)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(error);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(results);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>缺点:</p>
<ul>
<li>需要显示进行异常处理</li>
<li>为了不让嵌套层次太深，需要一个对request进行处理的函数</li>
<li>到处都是回调函数</li>
</ul>
<h4 id="使用Promise-then同时处理多个异步请求"><a href="#使用Promise-then同时处理多个异步请求" class="headerlink" title="使用Promise#then同时处理多个异步请求"></a>使用Promise#then同时处理多个异步请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">        resolve(req.responseText);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">    &#125;;</div><div class="line">    req.send();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> request = &#123;</div><div class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/comment.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;,</div><div class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/people.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</div><div class="line">    results.push(value);</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// [] 用来保存初始化的值</span></div><div class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</div><div class="line">  <span class="keyword">return</span> request.comment().then(pushValue).then(request.people).then(pushValue);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 运行的例子</span></div><div class="line">main().then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种方法也不是我们期望的，和上面的回调函数风格相比:</p>
<ul>
<li>可以直接使用<code>JSON.parse</code>函数</li>
<li>函数<code>main()</code>返回promise对象</li>
<li>错误处理的地方直接对返回的promise对象进行处理</li>
</ul>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p><code>Promise.all</code>接收一个promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用<code>.then</code>方法。比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">        resolve(req.responseText);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">    &#125;;</div><div class="line">    req.send();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> request = &#123;</div><div class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/comment.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;,</div><div class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getURL(<span class="string">'http://azu.github.io/promises-book/json/people.json'</span>).then(<span class="built_in">JSON</span>.parse);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([request.comment(), request.people()]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 运行示例</span></div><div class="line">main().then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样的优点是:</p>
<ul>
<li>main中的处理流程非常清晰</li>
<li>Promise.all接收promise对象组成的数组作为参数</li>
</ul>
<p>Promise数组是同时开始执行的，then调用参数的结果之中的results顺序和传递的数组的顺序一致。并且调用then的时间由最后一个完成的异步操作决定。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>它的使用方法和Promise.all一样，接收一个promise对象数组为参数。与all的区别就是：race只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。但是Promise中的数组也还是会继续执行。但是then只接受第一个完成的Promise返回对象。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://www.infoq.com/cn/news/2011/09/js-promise/" target="_blank" rel="external">JavaScript异步编程的Promise模式</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/18/乍暖还寒时候，最难将息/" class="prev"><button class="ui button teal">上一篇</button></a><a href="/2016/01/08/WEB跨域的实现/" class="next"><button class="ui button teal">下一篇</button></a></div><div data-thread-key="2016/01/20/JavaScript Learning - Promise入门/" data-title="JavaScript Learning - Promise入门" data-url="http://littlewin.info/2016/01/20/JavaScript Learning - Promise入门/" class="ds-share"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/01/20/JavaScript Learning - Promise入门/" data-title="JavaScript Learning - Promise入门" data-url="http://littlewin.info/2016/01/20/JavaScript Learning - Promise入门/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"littlewin"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://littlewin.info">Littlewin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and theme by <a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">casual</a></p></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/jquery.scrollex.js"></script><script src="/js/jquery.goup.min.js"></script><script src="/js/semantic.min.js"></script><script src="/js/casual.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>$(document).ready(function(){$.goup({trigger:100,bottomOffset:100,locationOffset: 0,title:'',titleAsText:true});});</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','TvAnFS4AVxjiJUvrZJRB','2.0.0');</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></div></body></html>