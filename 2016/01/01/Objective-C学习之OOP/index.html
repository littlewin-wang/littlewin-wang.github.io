<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Objective-C学习之OOP | Littlewin's blog</title><meta name="description" content="Objective-C学习之OOP - Littlewin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/casual.css"><link rel="stylesheet" href="/css/semantic.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://littlewin.info/atom.xml" title="Littlewin's blog"></head><body><div class="sidebar"><div class="ui vertical inverted menu"><div class="h100"></div><h3 class="ui inverted aligned icon header"><div class="content">LITTLEWIN'S BLOG</div></h3><div class="h50"></div><div class="side-nav"><a href="/" target="_self" class="item">HOME<i class="icon home"></i></a><a href="/archives" target="_self" class="item">ARCHIVE<i class="icon archive"></i></a><a href="/tags" target="_self" class="item">TAGS<i class="icon tags"></i></a><a href="/about" target="_self" class="item">INFO<i class="icon info"></i></a><a href="/atom.xml" target="_self" class="item">RSS<i class="icon rss"></i></a></div><div class="item"><div class="ui inverted transparent icon input"><input type="text" placeholder="Search..." class="st-default-search-input"><i class="search icon"></i></div></div><div class="h50"></div></div><div class="h50 mq"><a class="ui teal big label"><i class="content icon"></i></a></div><div class="author-info"><img src="/avatar.png" class="author-photo ui tiny circular image"><h4 class="ui aligned icon header"><div class="content">Littlewin</div></h4><p class="author-desc">朝着前端打怪升级中 | 目前从事闪存产品的固件和测试工具开发工作 | 多特蒙德死忠</p><div class="social-outer"><div class="social-inner"><a href="http://github.com/littlewin-wang" target="_blank" class="social-link"><i class="icon github"></i></a><a href="http://twitter.com/littlewin_wang" target="_blank" class="social-link"><i class="icon twitter"></i></a><a href="http://weibo.com/fredinweibo" target="_blank" class="social-link"><i class="icon weibo"></i></a></div></div></div></div><div class="main"><div class="wrap"><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Objective-C学习之OOP</h1><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jan 1, 2016</div></h6></div></div><div class="post-content"><p><em>最近元旦无事在家休息，将这半年来所学记录于此。以后无论事情再多，也要力争在短周期内通过blog上update自己的学习记录和心得，一来督促自己，二来方便日后查阅。</em></p>
<p>开发iOS应用需要使用Objective-C语言和Cocoa Touch框架。Objective-C源自C语言，是C语言的扩展。Cocoa Touch框架则是一个Objective-C类的集合。<br><a id="more"></a> </p>
<h5 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h5><p>Objective-C的类与其他OOP语言基本类似，是一种表示对象类型的结构体。对象通过它隶属的类来获取自身的各种信息，尤其是执行每个操作所要运行的代码。<br><code>@interface</code>指令将类所提供的数据结构成员告知Objective-C编译器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject  </div><div class="line">&#123;</div><div class="line">//fill in instance variable</div><div class="line">&#125;</div><div class="line">//fill in method declaration</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><code>@implementation</code>部分提供各个数据接口的功能代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@implementation NewClass</div><div class="line">//fill in implementation</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>在Objective-C中，几乎所有的类都是NSObject类的子类，因此，可以将这些类也看为对象，对象能够接收的消息列表是保存在它所对应的类中。每一个对象都有一个名为 isa 的指针，指向该对象的类。</p>
<p>NSObject 就是一个包含 isa 指针的结构体，它的定义如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject  &#123; </div><div class="line">    Class isa; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类是元类(metaclass)的实例，元类的isa指针指向根元类（root metaclass），根元类 (root metaclass) 本身的 isa 指针指向自己，形成一个闭环的继承路径。<br><img src="http://7xpot0.com1.z0.glb.clouddn.com/16-1-1/48692569.jpg" alt=""><br>对象是类的实例，其本身是分配在内存中的一块数据。对象是有生命周期的，首先被创建，然后接受消息，最后在不需要时被释放。向类发alloc消息，会在内存中创建对象并返回对象指针。对新创建的对象，必须先向其发送一个初始化消息，然后它才能正常工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NewClass *newClass = [NewClass alloc];</div><div class="line">[newClass init];</div></pre></td></tr></table></figure></p>
<p>在对象完成使命后，可以要求程序释放对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newClass=nil;</div></pre></td></tr></table></figure></p>
<h5 id="实例变量和属性"><a href="#实例变量和属性" class="headerlink" title="实例变量和属性"></a>实例变量和属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject</div><div class="line">&#123;</div><div class="line">    NSString *newString;</div><div class="line">&#125;</div><div class="line">@property (nonatomic, retain) NSString *newString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>声明类的实例变量时，需要将相应的声明写在花括号里，并紧跟在类声明的后面。为类添加实例变量后，还要定义存取方法（accessor method），否则无法访问对象的实例变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)setNewString:(NSString *)str;</div><div class="line">- (NSString *)newString;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)setNewString:(NSString *)str</div><div class="line">&#123;</div><div class="line">    _newString = str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)newString</div><div class="line">&#123;</div><div class="line">    return _newString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@Property</code>是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器。</p>
<p>它们的区别有以下几点</p>
<ul>
<li>直接操作实例变量明显更快。因为不需要经过OC的方法分发，直接从内存中读取。</li>
<li>直接写实例变量会绕过属性的内存管理声明，假如你的属性声明为 <code>copy</code>，直接写入它的实例变量将不会产生copy操作。</li>
<li>直接操作实例变量，不会发送KVO通知。</li>
<li>操作属性方便调试，你可以给get/set方法加断点，就能知道谁在什么时候进行了读写操作。</li>
</ul>
<h5 id="类方法和实例方法"><a href="#类方法和实例方法" class="headerlink" title="类方法和实例方法"></a>类方法和实例方法</h5><p>类方法的作用通常是创建对象，或者获取类的某些全局属性。<strong>类方法不会作用在在对象上，也不能存取实例变量</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (void)toNewString</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;this is a class method of NewString&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实例方法则用来操作类的对象（对象有时也可称为类的一个实例）例如上述存取方法。</p>
<p>在创建一个NewClass对象时，首先向NewClass类发送<code>alloc</code>（类方法）消息，然后向使用alloc方法创建的对象newClass发送<code>init</code>（实例方法）消息。</p>
<h5 id="继承与复合"><a href="#继承与复合" class="headerlink" title="继承与复合"></a>继承与复合</h5><p>继承（is-a关系）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject</div></pre></td></tr></table></figure></p>
<p>Objective-c不支持多继承。<br>Objective-c支持重写方法，同时仍然调用超类的实现方式，这时需要使用<code>super</code>关键词来调用父类方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[super init]；</div></pre></td></tr></table></figure></p>
<p>复合（has-a关系）<br>在objective-c中，复合是通过包含作为实例变量的对象指针实现的，如NewClass可以包含newString和oldString。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface NewClass : NSObject </div><div class="line">&#123; </div><div class="line">    NSString *newString; </div><div class="line">    NSString *oldString;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>严格来讲，只有对象间的组合才能叫复合，而基本类型都被认为是对象的一部分。</p>
<h5 id="一些没提到的关键字"><a href="#一些没提到的关键字" class="headerlink" title="一些没提到的关键字"></a>一些没提到的关键字</h5><ul>
<li><code>self</code> 与 <code>super</code><br><code>self</code> 是一个隐含的指针，指向接收消息的对象的指针。<br><code>super</code>既不是参数也不是实例变量。向<code>super</code>发消息时，实际上是在请求Objective-C向该类的超类发送消息。如果超类中没有定义的消息，Objective-C将按照继承的通常规则在继承链中查找。例如<code>[super init]</code>用于向超类的<code>init</code>方法发送消息。</li>
<li><code>id</code><br><code>id</code>是指向Objective-C类对象的指针，它可以声明为任何类对象的指针，当在Objective-C中使用id时，编译器会假定你知道，<code>id</code>指向哪个类的对象。与<code>void*</code>是不同的是，<code>void*</code>编译器不知道也不假定指向任何类型的指针。</li>
<li><code>nil</code><br>定义为一个常量，如果一个指针的值为<code>nil</code>,代表这个指针没有指向任何对象。</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/03/Objective-C学习之ARC/" class="prev"><button class="ui button teal">上一篇</button></a><a href="/2015/09/24/HTML进阶-优化设计/" class="next"><button class="ui button teal">下一篇</button></a></div><div data-thread-key="2016/01/01/Objective-C学习之OOP/" data-title="Objective-C学习之OOP" data-url="http://littlewin.info/2016/01/01/Objective-C学习之OOP/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"littlewin"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://littlewin.info">Littlewin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and theme by <a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">casual</a></p></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/jquery.scrollex.js"></script><script src="/js/semantic.min.js"></script><script src="/js/casual.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','TvAnFS4AVxjiJUvrZJRB','2.0.0');</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></div></body></html>